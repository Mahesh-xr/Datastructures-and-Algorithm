
Reverse a Doubly Linked List

**Problem Statement:** Given a doubly linked list of size **‘N’** consisting of positive integers, your task is to **reverse** it and return the head of the modified doubly linked list.

**Examples**

**Input :** DLL - 1 <-> 2 <-> 3 <-> 4

![](https://static.takeuforward.org/content/-9BDLjzqd)

**Output**: DLL - 4 <-> 3 <-> 2 <-> 1

![](https://static.takeuforward.org/content/-pAnIvST-)

**Explanation**: The doubly linked list is reversed and its last node is returned at the new head pointer.

**Input:** DLL-10 <-> 20 <-> 30

![](https://static.takeuforward.org/content/-VzqIdgCd)

**Output**: DLL - 30 <-> 20 <-> 10

![](https://static.takeuforward.org/content/-aMvAmPXW)

**Explanation**: In this case, the doubly linked list is reversed and its former tail is returned as its new head.

Brute Force Approach

Algorithm

A brute-force approach involves replacing data in a doubly linked list. First, we traverse the list and store node data in a stack. Then, in a second pass, we assign elements from the stack to nodes, ensuring a reverse order replacement since stacks follow the **Last-In-First-Out (LIFO)** principle.

- Initialization a **temp** pointer to the **head** of the doubly linked list and a **stack** data structure to store the values from the list.
- **Traverse** the doubly linked list with the **temp** pointer and while traversing push the value at the **current** **node** **temp** onto the stack. Move the **temp** to the **next** **node** continuing **until temp reaches null** indicating the end of the list.
- **Reset** the **temp** pointer back to the **head** of the list and in this second iteration **pop the element** from the stack, replace the data at the **current node** with the popped value from the **top** of the stack and move temp to the next node. Repeat this step until temp reaches **null** or the **stack** becomes **empty.**

![Image 1](https://static.takeuforward.org/content/1.png-t03m9-Q4)

![Image 2](https://static.takeuforward.org/content/2.png-MQky17vd)

![Image 3](https://static.takeuforward.org/content/3.png-wW_bo6mN)

![Image 4](https://static.takeuforward.org/content/4.png-zIxxkilt)

![Image 5](https://static.takeuforward.org/content/5.png-pYRE9FaX)

![Image 6](https://static.takeuforward.org/content/6.png-pjxahat6)

![Image 7](https://static.takeuforward.org/content/7.png-ZwPoKqQ2)

![Image 8](https://static.takeuforward.org/content/8.png-RoySExL5)

![Image 9](https://static.takeuforward.org/content/9.png-CceMUSb7)

![Image 10](https://static.takeuforward.org/content/10.png-yGikYdng)

![Image 1](https://static.takeuforward.org/content/1.png-t03m9-Q4)![Image 2](https://static.takeuforward.org/content/2.png-MQky17vd)![Image 3](https://static.takeuforward.org/content/3.png-wW_bo6mN)![Image 4](https://static.takeuforward.org/content/4.png-zIxxkilt)![Image 5](https://static.takeuforward.org/content/5.png-pYRE9FaX)![Image 6](https://static.takeuforward.org/content/6.png-pjxahat6)![Image 7](https://static.takeuforward.org/content/7.png-ZwPoKqQ2)![Image 8](https://static.takeuforward.org/content/8.png-RoySExL5)![Image 9](https://static.takeuforward.org/content/9.png-CceMUSb7)![Image 10](https://static.takeuforward.org/content/10.png-yGikYdng)

Code

C++JavaPythonJavaScript

```java
import java.util.*;

class Node {
    int data;
    Node next;
    Node back;

    // Constructor with data, next, and back
    Node(int data1, Node next1, Node back1) {
        data = data1;
        next = next1;
        back = back1;
    }

    // Constructor with only data
    Node(int data1) {
        data = data1;
        next = null;
        back = null;
    }
}

// Solution class with DLL methods
class Solution {

    // Function to convert array to doubly linked list
    public Node convertArr2DLL(int[] arr) {
        // Create the head node
        Node head = new Node(arr[0]);
        
        // Initialize previous pointer
        Node prev = head;

        // Traverse remaining array elements
        for (int i = 1; i < arr.length; i++) {
            // Create a new node and link back to previous
            Node temp = new Node(arr[i], null, prev);
            prev.next = temp;
            prev = temp;
        }

        // Return the head of DLL
        return head;
    }

    // Function to print the doubly linked list
    public void print(Node head) {
        // Traverse the list and print data
        while (head != null) {
            System.out.print(head.data + " ");
            head = head.next;
        }
    }

    // Function to reverse the DLL using stack
    public Node reverseDLL(Node head) {
        // If list is empty or has one element, return it
        if (head == null || head.next == null) {
            return head;
        }

        // Stack to store node values
        Stack<Integer> st = new Stack<>();

        // Pointer to traverse list
        Node temp = head;

        // Push all node data to stack
        while (temp != null) {
            st.push(temp.data);
            temp = temp.next;
        }

        // Reset temp to head
        temp = head;

        // Replace node values from stack
        while (temp != null) {
            temp.data = st.pop();
            temp = temp.next;
        }

        // Return updated head
        return head;
    }
}

// Main class to run the program
public class Main {
    public static void main(String[] args) {
        Solution sol = new Solution();

        // Input array
        int[] arr = {12, 5, 8, 7, 4};

        // Convert to DLL
        Node head = sol.convertArr2DLL(arr);

        System.out.println("Doubly Linked List Initially:");
        sol.print(head);

        // Reverse DLL
        head = sol.reverseDLL(head);

        System.out.println("\nDoubly Linked List After Reversing:");
        sol.print(head);
    }
}
```
Complexity Analysis

**Time Complexity : O(2N)**, During the first traversal, each node's value is pushed into the stack once, which requires O(N) time. Then, during the second iteration, the values are popped from the stack and used to update the nodes.

**Space Complexity : O(N)**, This is because we are using an external stack data structure. At the end of the first iteration, the stack will hold all N values of the doubly linked list therefore the space required for stack is directly proportional to the size of the input doubly linked list.

Optimal Approach

Algorithm

Instead of performing two separate traversals of the linked list and storing its node values in an external data structure, we can **optimize** our approach by directly **modifying the links between the nodes** within the doubly linked list We need to traverse on every node, and for every node change the next pointer and back pointer. If we can do this for all nodes, at the end of traversal, the doubly linked list will be reversed.

- Initialise **two pointers** that are needed for the reversal. Initialize a **current** pointer to the **head** of the linked list. This pointer will **traverse** the list as we **reverse** it. Initialize a second pointer **last** to null. This pointer will be used for **temporary s****torage** during **pointer swapping,** as we need a third variable while swapping two data**.**
- Traverse through the DLL by looping over all the nodes.
- While iterating over all nodes in the linked list, we make changes to set the **backward** pointer of a node to the **next** changing its **previous** **link**. Along with this, the **forward** pointer is adjusted to point to the **previous** node, reversing the **next** **link**. To prevent losing the last node in this process, we use a **reference** to the **last** **node** to retain it.
- Update the **current** **node's** **back** pointer to point to the **next** **node** (c**urrent->back = current->next**). This step reverses the direction of the **backward** pointer.
- Update the **current** **node's** **next** pointer to point to the **previous** **node** (current->next = last). This step r**everses the direction of the forward pointer.**
- Move the current pointer **one step forward** (current = current->back). This allows us to continue the reversal process.
- After completing the traversal, the **last** node ends up at the **second** **node** in the reversed doubly linked list. To obtain the **new** **head** of the reversed list, we simply use the **backward** **pointer** of the **last** **node**, which points to the **new** **head**.
- To ensure that we handle the case where the traversal ended at the original list's end (i.e., the last pointer is not null), we **update** the **head** **pointer** to point to the **new** **head** of the reversed list, which is stored in the **last** **pointer**.
- Finally, we return the **head** **pointer**, now pointing to the head of the fully reversed doubly linked list.

![Image 1](https://static.takeuforward.org/content/1.png-aTyTb2sl)

![Image 2](https://static.takeuforward.org/content/2.png-ku5k5E5F)

![Image 3](https://static.takeuforward.org/content/3.png-UW1EnIFJ)

![Image 4](https://static.takeuforward.org/content/4.png-nqv-CHmO)

![Image 5](https://static.takeuforward.org/content/5.png-WoB6kq62)

![Image 6](https://static.takeuforward.org/content/6.png-z_zlAC8P)

![Image 7](https://static.takeuforward.org/content/7.png-IzP8pAAo)

![Image 1](https://static.takeuforward.org/content/1.png-aTyTb2sl)![Image 2](https://static.takeuforward.org/content/2.png-ku5k5E5F)![Image 3](https://static.takeuforward.org/content/3.png-UW1EnIFJ)![Image 4](https://static.takeuforward.org/content/4.png-nqv-CHmO)![Image 5](https://static.takeuforward.org/content/5.png-WoB6kq62)![Image 6](https://static.takeuforward.org/content/6.png-z_zlAC8P)![Image 7](https://static.takeuforward.org/content/7.png-IzP8pAAo)

Code

C++JavaPythonJavaScript

```java
import java.util.*;
// Node class representing a doubly linked list node
class Node {
    int data;
    Node next;
    Node back;

    // Constructor to initialize data only
    Node(int data) {
        this.data = data;
        this.next = null;
        this.back = null;
    }

    // Constructor to initialize data, next, and back
    Node(int data, Node next, Node back) {
        this.data = data;
        this.next = next;
        this.back = back;
    }
}

// Solution class that contains core logic
class Solution {

    // Function to convert an array into a doubly linked list
    public Node convertArr2DLL(int[] arr) {

        // Creating the head of the DLL using the first array element
        Node head = new Node(arr[0]);

        // Initializing previous pointer to head
        Node prev = head;

        // Loop through rest of the array to construct DLL
        for (int i = 1; i < arr.length; i++) {

            // Create new node with current value, null next, and prev back pointer
            Node temp = new Node(arr[i], null, prev);

            // Connect previous node's next to this new node
            prev.next = temp;

            // Move prev to this new node
            prev = temp;
        }

        // Return the head of the constructed DLL
        return head;
    }

    // Function to reverse the doubly linked list
    public Node reverseDLL(Node head) {

        // Pointer to traverse the list
        Node current = head;

        // Variable to eventually store new head after reversal
        Node last = null;

        // Traverse the entire list
        while (current != null) {

            // Swap next and back pointers of current node
            Node temp = current.next;
            current.next = current.back;
            current.back = temp;

            // Move last pointer to current (this will become new head)
            last = current;

            // Move to next node (originally current.next but now is back due to swap)
            current = temp;
        }

        // Return the new head (was the last node in original list)
        return last;
    }

    // Function to print the DLL from head to end
    public void printDLL(Node head) {

        // Traverse till end
        while (head != null) {
            System.out.print(head.data + " ");
            head = head.next;
        }

        System.out.println();
    }
}
// driver class 
public class Main {
    public static void main(String[] args) {

        // Create an instance of Solution class
        Solution sol = new Solution();

        // Sample array input
        int[] arr = {1, 2, 3, 4, 5};

        // Convert array to DLL
        Node head = sol.convertArr2DLL(arr);

        // Print the original DLL
        System.out.print("Original DLL: ");
        sol.printDLL(head);

        // Reverse the DLL
        Node reversed = sol.reverseDLL(head);

        // Print the reversed DLL
        System.out.print("Reversed DLL: ");
        sol.printDLL(reversed);
    }
}
```
Complexity Analysis

**Time Complexity : O(N)** We only have to **traverse** the doubly linked list **once**, hence our time complexity is O(N).

**Space Complexity : O(1),** as the reversal is done in place.