
## Introduction to Singly LinkedList

Imagine a train with a series of carriages connected together. Each carriage can be added or removed independently without disturbing the others. This is similar to a linked list, where each element (carriage) points to the next, allowing for flexible addition and removal.  
In contrast, think of an array as a train where all carriages are welded together. Adding or removing a carriage in the middle would require shifting all the subsequent carriages, making the process laborious and inefficient.  
So, if you frequently need to add or remove carriages (elements) in your application, a linked list is like having a train with detachable carriages, providing greater flexibility and efficiency.  

### What is a Linked List ?

A linked list is a linear data structure resembling a chain, where each node is connected to the next, and each node represents an individual element. Unlike arrays, the elements in a linked list are not stored in contiguous memory locations.  
In arrays, adding a new element requires the next memory location to be empty, which cannot always be guaranteed. Therefore, expanding an array beyond its initial size can be challenging and inefficient. This limitation is not present in linked lists, which can dynamically grow and shrink as needed.  
  
![](https://static.takeuforward.org/premium/Linked-List/Fundamentals%20Single%20LL/Introduction%20to%20Singly%20LinkedList/array%20vs%20ll-AzyLrwKg)  
  
A linked list is a data structure containing two crucial pieces of information, the first being the data and the other being the pointer to the next element. The ‘head’ is the first node, and the ‘tail’ is the last node in a linked list. ![](https://static.takeuforward.org/premium/Linked-List/Fundamentals%20Single%20LL/Introduction%20to%20Singly%20LinkedList/ll-MWVVUUBH)  
  

### Why Linked List over arrays ?

Unlike arrays, the size of the Linked List can be decreased or increased at any location and at any point of time efficiently.

### Difference Between Struct and Class in Linked Lists

|Aspect|Struct|Class|
|---|---|---|
|**Definition**|A `struct` is a user-defined data type that groups together different data types to form a single unit. It is primarily used for simple data structures.|A `class` is a blueprint for creating objects, providing more advanced features such as inheritance, encapsulation, and polymorphism.|
|**Access Control**|By default, all members of a `struct` are public.|By default, all members of a `class` are private.|
|**Usage in Linked Lists**|Often used for defining the nodes in a simple linked list where each node typically contains data and a pointer to the next node.|Used for defining more complex linked list structures that require encapsulation and additional functionality, such as methods for insertion, deletion, and traversal.|
|**Memory Management**|Typically used in simpler scenarios with straightforward memory management, often using stack allocation.|More suitable for dynamic memory management using heap allocation, allowing for more control over the lifecycle of linked list nodes.|
|**Example**|struct Node {<br>    int data;<br>    Node* next;<br>};|class Node {<br>private:<br>    int data;<br>    Node* next;<br>public:<br>    Node(int data) : data(data), next(nullptr) {}<br>    int getData() { return data; }<br>    Node* getNext() { return next; }<br>    void setNext(Node* nextNode) { next = nextNode; }<br>};|

### Creating a Linked List



```java
import java.util.*;

class Node {
    public int data;
    public Node next;

    public Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }
}

public class Main {
    public static void main(String[] args) {
        ArrayList<Integer> arr = new ArrayList<>();
        arr.add(2);
        arr.add(5);
        arr.add(8);
        arr.add(7);

        /* 
         * Assigning values to 
         * the nodes 
         */
        Node y1 = new Node(arr.get(0), null);
        Node y2 = new Node(arr.get(1), null);
        Node y3 = new Node(arr.get(2), null);
        Node y4 = new Node(arr.get(3), null);

        /* 
         * Linking of 
         * Nodes 
         */
        y1.next = y2;
        y2.next = y3;
        y3.next = y4;

        /* 
         * Printing Nodes with their 
         * values and data 
         */
        System.out.println(y1.data + " " + y1.next);
        System.out.println(y2.data + " " + y2.next);
        System.out.println(y3.data + " " + y3.next);
        System.out.println(y4.data + " " + y4.next);
    }
}
```

  

Let's break this code to understand how it works:

- The struct has two data types: `data` which contains the value of the node and a pointer `next`, which points to the next node in the list.
- There is a constructor which assigns the values to a new node.
- A `new` keyword is used to dynamically allocate memory to a node with `data` as `arr[0]`.

The combination of the given parameters and functions initializes a linked list.

### Understanding Pointers

A pointer is a variable that stores the memory address of another variable. In simpler terms, it "points" to the location in memory where data is stored. This allows you to indirectly access and manipulate data by referring to its memory address.

Pointers are a powerful feature in C++ that enable dynamic memory allocation and the creation of complex data structures like linked lists, trees, and graphs. They are declared using an asterisk (*) before the pointer name, and the address-of operator (&) is used to obtain the memory address of a variable.

For example, if you have a variable `int x = 10;`, a pointer to this variable can be declared as `int* ptr = &x;`. The pointer `ptr` now holds the memory address of `x`. You can access the value of `x` indirectly through the pointer by using the dereference operator (*), like this: `*ptr`.

Pointers are essential for efficient memory management and are widely used in low-level programming, performance optimization, and working with advanced data structures. Understanding how to use pointers effectively can greatly enhance your ability to write efficient and powerful C++ programs.

  

C++

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int x = 10; 
    // Declare a pointer and assign it the address of x
    int* ptr = &x;     

    // Print the value of x and the address of x
    cout << "Value of x: " << x << endl;
    cout << "Address of x: " << &x << endl;

    // Print the value stored in ptr and the value pointed to by ptr
    cout << "Value stored in ptr (address of x): " << ptr << endl;
    cout << "Value pointed to by ptr: " << *ptr << endl;

    // Modify the value of x using the pointer
    *ptr = 20;

    // Print the new value of x
    cout << "New value of x after modification: " << x << endl;

    return 0;
}
```

  

Value of x: 10

Address of x: 0x7ffde8dbc7e4

Value stored in ptr (address of x): 0x7ffde8dbc7e4

Value pointed to by ptr: 10

New value of x after modification: 20

### Difference Between `Node` and `Node*`

In C++, the terms `Node` and `Node*` are related but refer to different concepts:

- **`Node`:**
    - This represents a variable of type `Node`.
    - It is an instance of the `Node` structure or class.
    - When you declare a variable as `Node`, it directly holds the data and any member variables defined in the `Node` structure or class.
    - Example: `Node node1;` creates a `Node` object named `node1`.
- **`Node*`:**
    - This represents a pointer to a `Node` type.
    - It does not hold the actual data but rather the memory address where a `Node` object is stored.
    - Using a pointer allows for dynamic memory allocation, meaning you can create and manage nodes at runtime using the `new` operator.
    - Example: `Node* nodePtr = new Node();` creates a pointer to a dynamically allocated `Node` object.

### Memory Space

Let's consider storing integers. A key difference between arrays and linked lists is their memory usage. For arrays, each integer takes up 4 bytes of memory. In contrast, linked lists store both data and a pointer in each node, so the memory usage depends on the system configuration.

![](https://static.takeuforward.org/premium/Linked-List/Fundamentals%20Single%20LL/Introduction%20to%20Singly%20LinkedList/-2NGBFlDT)

Therefore, on a 64-bit system, linked lists use more memory compared to a 32-bit system.

### Applications of Linked Lists:

- **Creating Data Structures:** Linked lists serve as the foundation for building other dynamic data structures, such as stacks and queues.
- **Dynamic Memory Allocation:** Dynamic memory allocation relies on linked lists to manage and allocate memory blocks efficiently.
- **Web Browser:** Web browsers use linked lists to manage the history of visited pages.

### Types of Linked List

- **Singly Linked Lists:** In a singly linked list, each node points to the next node in the sequence. Traversal is straightforward but limited to moving in one direction, from the head to the tail.
    
    ![](https://static.takeuforward.org/premium/Linked-List/Fundamentals%20Single%20LL/Introduction%20to%20Singly%20LinkedList/sll-P9SpQQ30)
    
- **Doubly Linked Lists:** In this type, each node points to both the next node and the previous node, allowing for bidirectional connectivity.
    
    ![](https://static.takeuforward.org/premium/Linked-List/Fundamentals%20Single%20LL/Introduction%20to%20Singly%20LinkedList/dll-N0dKgRlP)
    
- **Circular Linked Lists:** In a circular linked list, the last node points back to the head node, forming a closed loop.
    
    ![](https://static.takeuforward.org/premium/Linked-List/Fundamentals%20Single%20LL/Introduction%20to%20Singly%20LinkedList/cll-e9RXSPbg)
    

### Convert an array to Linked List

C++JavaPythonJavaScriptC#Go

```cpp
#include <bits/stdc++.h>
using namespace std;

// Define a Node structure
struct Node {
    int data;
    Node* next;
    
    // Constructor to initialize a new node
    Node(int val) : data(val), next(nullptr) {}
};

// Function to convert an array to a linked list
Node* arrayToLinkedList(int arr[], int size) {
    if (size == 0) return nullptr;

    // Create head of the linked list
    Node* head = new Node(arr[0]);
    Node* current = head;

   /* Iterate through the array 
   and create linked list nodes*/
    for (int i = 1; i < size; i++) {
        current->next = new Node(arr[i]);
        current = current->next;
    }

    return head;
}

// Function to print the linked list
void printLinkedList(Node* head) {
    Node* current = head;
    while (current != nullptr) {
        cout << current->data << " -> ";
        current = current->next;
    }
    cout << "nullptr" << endl;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]);

    // Convert array to linked list
    Node* head = arrayToLinkedList(arr, size);

    // Print the linked list
    printLinkedList(head);

    return 0;
}
```

###### Output:-

1 -> 2 -> 3 -> 4 -> 5 -> nullptr

### Length of Linked List

C++JavaPythonJavaScriptC#Go

```cpp
#include <bits/stdc++.h>
using namespace std;

// Define a Node structure
struct Node {
    int data;
    Node* next;

    // Constructor to initialize a new node
    Node(int val) : data(val), next(nullptr) {}
};

// Function to convert an array to a linked list
Node* arrayToLinkedList(int arr[], int size) {
    if (size == 0) return nullptr;

    // Create head of the linked list
    Node* head = new Node(arr[0]);
    Node* current = head;

   /* Iterate through the array 
   and create linked list nodes */
    for (int i = 1; i < size; i++) {
        current->next = new Node(arr[i]);
        current = current->next;
    }

    return head;
}

// Function to print the linked list
void printLinkedList(Node* head) {
    Node* current = head;
    while (current != nullptr) {
        cout << current->data << " -> ";
        current = current->next;
    }
    cout << "nullptr" << endl;
}

// To calculate length of linked list
int lengthOfLinkedList(Node* head) {
    int length = 0;
    Node* current = head;
    
    // Count the nodes
    while (current != nullptr) {
        length++;
        current = current->next;
    }
    
    return length;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int size = sizeof(arr) / sizeof(arr[0]);

    // Convert array to linked list
    Node* head = arrayToLinkedList(arr, size);

    // Print the linked list
    printLinkedList(head);

    // Calculate the length of the linked list
    int length = lengthOfLinkedList(head);
    cout << "Length of the linked list: " << length << endl;

    return 0;
}
```

Length of the linked list: 5

### Search an Element in Linked List

C++JavaPythonJavaScriptC#Go

```cpp
#include <bits/stdc++.h>
using namespace std;

using namespace std;

// Define a Node structure
struct Node {
    int data;
    Node* next;

    // Constructor to initialize a new node
    Node(int val) : data(val), next(nullptr) {}
};

// Function to print the linked list
void printLinkedList(Node* head) {
    Node* current = head;
    while (current != nullptr) {
        cout << current->data << " -> ";
        current = current->next;
    }
    cout << "nullptr" << endl;
}

// To search for an element in the linked list
bool searchElement(Node* head, int target) {
    Node* current = head;

    // Traverse the linked list
    while (current != nullptr) {
        if (current->data == target) {
            return true;
        }
        current = current->next;
    }

    return false;
}

int main() {
    // Create a linked list manually 
    Node* head = new Node(1);
    head->next = new Node(2);
    head->next->next = new Node(3);
    head->next->next->next = new Node(4);
    head->next->next->next->next = new Node(5);

    // Print the linked list
    printLinkedList(head);

    // Search for an element in the linked list
    int target = 3;
    if (searchElement(head, target)) {
        cout << "Element " << target << " found in the linked list." << endl;
    } else {
        cout << "Element " << target << " not found in the linked list." << endl;
    }

    return 0;
}
```

###### Output:-

1 -> 2 -> 3 -> 4 -> 5 -> None

Element 3 found in the linked list.