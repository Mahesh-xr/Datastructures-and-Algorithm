
Find intersection of Two Linked Lists

**Problem Statement:** Given the heads of two singly [linked-lists](https://takeuforward.org/linked-list/linked-list-introduction/) **headA** and **headB**, return **the node at which the two lists intersect**. If the two linked lists have no intersection at all, return **null**.

**Examples**

**Example 1:****Input:**
List 1 = [1,3,1,2,4], List 2 = [3,2,4]
**Output:**
2
**Explanation:** Here, both lists intersecting nodes start from node 2.
![](https://static.takeuforward.org/content/-IIhJezoO)

**Example 2:****Input:**
 List1 = [1,2,7], List 2 = [2,8,1]
**Output:**
 Null
**Explanation:** Here, both lists do not intersect and thus no intersection node is present.
**![](https://static.takeuforward.org/content/-KTSP9UDO)**

Brute Force Approach

Algorithm

**Approach:** We know intersection means a common attribute present between two entities. Here, we have linked lists as given entities. 

What should be the common attribute for two linked lists? 

If you believe a common attribute is a node's value, then think properly! If we take our example 1, there we can see both lists have nodes of value 3. But it is not the first intersection node. So what’s the common attribute?

It is the node itself that is the common attribute. So, the process is as follows:-

- Keep any one of the list to check its node present in the other list. Here, we are choosing the second list for this task.
- Iterate through the other list. Here, it is the first one. 
- Check if the both nodes are the same. If yes, we got our first intersection node.
- If not, continue iteration.
- If we did not find an intersection node and completed the entire iteration of the second list, then there is no intersection between the provided lists. Hence, return _null_.

**Dry Run:**

Code

C++JavaPythonJavaScript

```java
class Node {
    int num;
    Node next;
    Node(int val) {
        num = val;
        next = null;
    }
}

class Solution {
    // Utility function to insert node at the end of the linked list
    public void insertNode(Node head, int val) {
        Node newNode = new Node(val);
        if (head == null) {
            head = newNode;
            return;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
    }

    // Utility function to check presence of intersection
    public Node intersectionPresent(Node head1, Node head2) {
        while (head2 != null) {
            Node temp = head1;
            while (temp != null) {
                if (temp == head2) return head2;
                temp = temp.next;
            }
            head2 = head2.next;
        }
        return null; // No intersection found
    }

    // Utility function to print linked list
    public void printList(Node head) {
        while (head != null && head.next != null) {
            System.out.print(head.num + "->");
            head = head.next;
        }
        if (head != null) {
            System.out.print(head.num);
        }
        System.out.println();
    }
}

public class Main {
    public static void main(String[] args) {
        Solution sol = new Solution();

        // Creation of both lists
        Node head = new Node(1);
        sol.insertNode(head, 3);
        sol.insertNode(head, 1);
        sol.insertNode(head, 2);
        sol.insertNode(head, 4);
        Node head1 = head;
        head = head.next.next.next; // Intersection point
        Node headSec = new Node(3);
        Node head2 = headSec;
        headSec.next = head; // Creating intersection

        // Printing of the lists
        System.out.print("List1: ");
        sol.printList(head1);
        System.out.print("List2: ");
        sol.printList(head2);

        // Checking if intersection is present
        Node answerNode = sol.intersectionPresent(head1, head2);
        if (answerNode == null) {
            System.out.println("No intersection");
        } else {
            System.out.println("The intersection point is " + answerNode.num);
        }
    }
}
```
Complexity Analysis

**Time Complexity: O(m × n)**, For each node in list 2, the entire list 1 is iterated, resulting in nested iterations.

**Space Complexity: O(1)**, No extra space is used; the comparison is done in-place.

Better Approach

Algorithm

In brute force, we are basically performing “searching”. We can also perform searches by Hashing. Taking into consideration that hashing process takes O(1) time complexity. So the process is as follows:-

- Iterate through list 1 and hash its node address. Why? (Hint: depends on the common attribute we are searching)
- Iterate through list 2 and search the hashed value in the hash table. If found, return node.

Code

C++JavaPythonJavaScript

```java
import java.util.*;

class Solution {
    // Utility function to insert node at the end of the linked list
    public void insertNode(Node head, int val) {
        Node newNode = new Node(val);
        if (head == null) {
            head = newNode;
            return;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
    }

    // Utility function to check presence of intersection
    public Node intersectionPresent(Node head1, Node head2) {
        Set<Node> st = new HashSet<>();  // Set to store visited nodes from the first list
        while (head1 != null) {
            st.add(head1);  // Add nodes of the first list to the set
            head1 = head1.next;
        }
        while (head2 != null) {
            if (st.contains(head2)) return head2;  // If node is found in set, it's the intersection point
            head2 = head2.next;
        }
        return null;  // Return null if no intersection is found
    }

    // Utility function to print linked list
    public void printList(Node head) {
        while (head != null && head.next != null) {
            System.out.print(head.num + "->");
            head = head.next;
        }
        if (head != null) {
            System.out.print(head.num);
        }
        System.out.println();
    }
}

class Node {
    int num;
    Node next;
    Node(int val) {
        num = val;
        next = null;
    }
}

public class Main {
    public static void main(String[] args) {
        Solution sol = new Solution();

        // Creation of both lists
        Node head = new Node(1);
        sol.insertNode(head, 3);
        sol.insertNode(head, 1);
        sol.insertNode(head, 2);
        sol.insertNode(head, 4);
        Node head1 = head;
        head = head.next.next.next;  // Intersection point
        Node headSec = new Node(3);
        Node head2 = headSec;
        headSec.next = head;  // Creating intersection

        // Printing the lists
        System.out.print("List1: ");
        sol.printList(head1);
        System.out.print("List2: ");
        sol.printList(head2);

        // Checking if intersection is present
        Node answerNode = sol.intersectionPresent(head1, head2);
        if (answerNode == null) {
            System.out.println("No intersection");
        } else {
            System.out.println("The intersection point is " + answerNode.num);
        }
    }
}
```
Complexity Analysis

**Time Complexity: O(n + m)**, Iterating through list 1 first takes O(n), then iterating through list 2 takes O(m).

**Space Complexity: O(n)**, Storing list 1 node addresses in an unordered_set.

Optimal Approach 1

Algorithm

We will reduce the search length. This can be done by searching the length of the shorter linked list. How? Let’s see the process.

- Find the length of both lists.
- Find the positive difference between these lengths.
- Move the dummy pointer of the larger list by the difference achieved. This makes our search length reduced to a smaller list length.
- Move both pointers, each pointing two lists, ahead simultaneously if both do not collide.

Code

C++JavaPythonJavaScript

```java
import java.util.*;

class Node {
    int num;
    Node next;
    Node(int val) {
        num = val;
        next = null;
    }
}

class Solution {
    // Utility function to insert node at the end of the linked list
    public void insertNode(Node head, int val) {
        Node newNode = new Node(val);
        if (head == null) {
            head = newNode;
            return;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
    }

    // Utility function to get the difference in lengths of two linked lists
    public int getDifference(Node head1, Node head2) {
        int len1 = 0, len2 = 0;
        while (head1 != null || head2 != null) {
            if (head1 != null) {
                len1++;
                head1 = head1.next;
            }
            if (head2 != null) {
                len2++;
                head2 = head2.next;
            }
        }
        return len1 - len2;  // If negative, length of list2 > length of list1, else vice-versa
    }

    // Utility function to check presence of intersection
    public Node intersectionPresent(Node head1, Node head2) {
        int diff = getDifference(head1, head2);

        if (diff < 0) {
            while (diff++ != 0) head2 = head2.next;
        } else {
            while (diff-- != 0) head1 = head1.next;
        }

        // Traverse both lists and compare node by node
        while (head1 != null) {
            if (head1 == head2) return head1;  // Intersection point found
            head2 = head2.next;
            head1 = head1.next;
        }
        return null;  // Return null if no intersection
    }

    // Utility function to print linked list
    public void printList(Node head) {
        while (head != null && head.next != null) {
            System.out.print(head.num + "->");
            head = head.next;
        }
        if (head != null) {
            System.out.print(head.num);
        }
        System.out.println();
    }
}

public class Main {
    public static void main(String[] args) {
        Solution sol = new Solution();

        // Creation of both lists
        Node head = new Node(1);
        sol.insertNode(head, 3);
        sol.insertNode(head, 1);
        sol.insertNode(head, 2);
        sol.insertNode(head, 4);
        Node head1 = head;
        head = head.next.next.next;  // Intersection point
        Node headSec = new Node(3);
        Node head2 = headSec;
        headSec.next = head;  // Creating intersection

        // Printing the lists
        System.out.print("List1: ");
        sol.printList(head1);
        System.out.print("List2: ");
        sol.printList(head2);

        // Checking if intersection is present
        Node answerNode = sol.intersectionPresent(head1, head2);
        if (answerNode == null) {
            System.out.println("No intersection");
        } else {
            System.out.println("The intersection point is " + answerNode.num);
        }
    }
}
```
Complexity Analysis

**Time Complexity: O(2 × max(length of list1, length of list2)) + O(abs(length of list1 − length of list2)) + O(min(length of list1, length of list2))**, Finding the length of both lists takes O(max) time since it's done simultaneously, then moving one pointer by the difference in lengths, and finally searching for the intersection.

**Space Complexity: O(1)**, No extra space is used.

Optimal Approach 2

Algorithm

The difference of length method requires various steps to work on it. Using the same concept of difference of length, a different approach can be implemented. The process is as follows:-

- Take two dummy nodes for each list. Point each to the head of the lists.
- Iterate over them. If anyone becomes null, point them to the head of the opposite lists and continue iterating until they collide.

**Dry** **Run**:

![Image 1](https://static.takeuforward.org/content/1.png-wxb_3WCk)

![Image 2](https://static.takeuforward.org/content/2.png--9w-i90U)

![Image 3](https://static.takeuforward.org/content/3.png-D5rDSjcY)

![Image 4](https://static.takeuforward.org/content/4.png-StwP-Yzo)

![Image 5](https://static.takeuforward.org/content/5.png-eY21wJ59)

![Image 6](https://static.takeuforward.org/content/6.png-nDm-7tqz)

![Image 7](https://static.takeuforward.org/content/7.png-XTaiijVU)

![Image 8](https://static.takeuforward.org/content/8.png-BAWfB4X2)

![Image 9](https://static.takeuforward.org/content/9.png-36Yyla9n)

![Image 10](https://static.takeuforward.org/content/10.png-sLFeC3pw)

![Image 1](https://static.takeuforward.org/content/1.png-wxb_3WCk)![Image 2](https://static.takeuforward.org/content/2.png--9w-i90U)![Image 3](https://static.takeuforward.org/content/3.png-D5rDSjcY)![Image 4](https://static.takeuforward.org/content/4.png-StwP-Yzo)![Image 5](https://static.takeuforward.org/content/5.png-eY21wJ59)![Image 6](https://static.takeuforward.org/content/6.png-nDm-7tqz)![Image 7](https://static.takeuforward.org/content/7.png-XTaiijVU)![Image 8](https://static.takeuforward.org/content/8.png-BAWfB4X2)![Image 9](https://static.takeuforward.org/content/9.png-36Yyla9n)![Image 10](https://static.takeuforward.org/content/10.png-sLFeC3pw)

Code

C++JavaPythonJavaScript

```java
class Node {
    int num;
    Node next;
    Node(int val) {
        num = val;
        next = null;
    }
}

class Solution {
    // Utility function to insert node at the end of the linked list
    public void insertNode(Node head, int val) {
        Node newNode = new Node(val);
        if (head == null) {
            head = newNode;
            return;
        }
        Node temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = newNode;
    }

    // Utility function to check presence of intersection
    public Node intersectionPresent(Node head1, Node head2) {
        Node d1 = head1;
        Node d2 = head2;

        // Traverse both lists, when one reaches the end, redirect it to the head of the other list
        while (d1 != d2) {
            d1 = d1 == null ? head2 : d1.next;
            d2 = d2 == null ? head1 : d2.next;
        }

        return d1;  // If they meet, return the intersection node, otherwise NULL
    }

    // Utility function to print linked list
    public void printList(Node head) {
        while (head != null && head.next != null) {
            System.out.print(head.num + "->");
            head = head.next;
        }
        if (head != null) {
            System.out.print(head.num);
        }
        System.out.println();
    }
}

public class Main {
    public static void main(String[] args) {
        Solution sol = new Solution();

        // Creation of both lists
        Node head = new Node(1);
        sol.insertNode(head, 3);
        sol.insertNode(head, 1);
        sol.insertNode(head, 2);
        sol.insertNode(head, 4);
        Node head1 = head;
        head = head.next.next.next;  // Intersection point
        Node headSec = new Node(3);
        Node head2 = headSec;
        headSec.next = head;  // Creating intersection

        // Printing the lists
        System.out.print("List1: ");
        sol.printList(head1);
        System.out.print("List2: ");
        sol.printList(head2);

        // Checking if intersection is present
        Node answerNode = sol.intersectionPresent(head1, head2);
        if (answerNode == null) {
            System.out.println("No intersection");
        } else {
            System.out.println("The intersection point is " + answerNode.num);
        }
    }
}
```
Complexity Analysis

**Time Complexity: O(2 × max(length of list1, length of list2))**, Uses the same concept of difference of lengths of two lists.

**Space Complexity: O(1)**, No extra data structure is used.

Video Solution