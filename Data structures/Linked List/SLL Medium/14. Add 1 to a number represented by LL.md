Add 1 to a number represented by LL

**Problem Statement:** Given the head of a singly linked list representing a positive integer number. Each node of the linked list represents a digit of the number, with the 1st node containing the leftmost digit of the number and so on. The task is to add one to the value represented by the linked list and return the head of a linked list containing the final value.

The number will contain no leading zeroes except when the value represented is zero itself.

**Examples**

Input: 4->5->6
Output: 4->5->7Explanation: 456 + 1 = 457

Input: 9->9->9
Output: 1->0->0->0Explanation: 999 + 1 = 1000

Iterative approach

Algorithm

Since the least significant digit is at the end of the list, we can’t process it directly using a single traversal. Therefore, to perform addition from the end, we need to reverse the list.

- Reverse the list and start from the head and add 1. Carry it forward as needed.
- If a carry remains after the last node, add a new node with value 1.
- Reverse the list again to restore the original order and return the head of the modified list.

![Image 1](https://static.takeuforward.org/content/1.png-9sdo30jv)

![Image 2](https://static.takeuforward.org/content/2.png-3aflyYFO)

![Image 3](https://static.takeuforward.org/content/3.png-c1MTUkyk)

![Image 4](https://static.takeuforward.org/content/4.png-TdXbeJDV)

![Image 5](https://static.takeuforward.org/content/5.png-gE-VYL9F)

![Image 1](https://static.takeuforward.org/content/1.png-9sdo30jv)![Image 2](https://static.takeuforward.org/content/2.png-3aflyYFO)![Image 3](https://static.takeuforward.org/content/3.png-c1MTUkyk)![Image 4](https://static.takeuforward.org/content/4.png-TdXbeJDV)![Image 5](https://static.takeuforward.org/content/5.png-gE-VYL9F)

Code

C++JavaPythonJavaScript

```java
// Node class representing a single digit in the linked list
class Node {
    int data;
    Node next;

    Node(int value) {
        data = value;
        next = null;
    }
}

// LinkedList class to manage node-level operations
class LinkedList {
    // function to insert digit at the end
    Node append(Node head, int value) {
        Node newNode = new Node(value);
        if (head == null) {
            return newNode;
        }
        Node current = head;
        while (current.next != null)
            current = current.next;
        current.next = newNode;
        return head;
    }

    // Function to print the list
    void printList(Node head) {
        Node current = head;
        while (current != null) {
            System.out.print(current.data);
            current = current.next;
        }
        System.out.println();
    }
}

// Solution class having the addOne logic 
class Solution {
    // function to reverse the linked list
    Node reverseList(Node node) {
        Node prev = null;
        Node current = node;

        while (current != null) {
            Node nextNode = current.next;
            current.next = prev;
            prev = current;
            current = nextNode;
        }
        return prev;
    }

    // Function to add one to the number represented by the linked list
    Node addOne(Node head) {
        // Reverse the list to make least significant digit accessible
        head = reverseList(head);

        Node current = head;
        int carry = 1; 

        // Traverse the list and add carry
        while (current != null && carry > 0) {
            int sum = current.data + carry;
            current.data = sum % 10;
            carry = sum / 10;

            // If there's no next node and we still have a carry, append a new node
            if (current.next == null && carry > 0) {
                current.next = new Node(carry);
                carry = 0;  
            }

            current = current.next;
        }

        // Reverse the list back to restore original order
        head = reverseList(head);
        return head;
    }
}

// Main class to run the program
public class Main {
    public static void main(String[] args) {
        Node head = null;
        LinkedList ll = new LinkedList();
        Solution sol = new Solution();

        // Example: Number 129 (1 -> 2 -> 9)
        head = ll.append(head, 1);
        head = ll.append(head, 2);
        head = ll.append(head, 9);

        System.out.print("Original Number: ");
        ll.printList(head);

        head = sol.addOne(head);

        System.out.print("After Adding One: ");
        ll.printList(head);
    }
}
```
Complexity Analysis**Time Complexity: O(n)**, Two reversals + one pass for addition.  
**Space Complexity: O(1)**, Iterative, no extra stack used.

Recursive approach

Algorithm

Since the number is stored in most-significant-digit first order, it’s difficult to perform addition directly because we need to handle carry from the last digit (least significant digit). Using recursion, we can traverse to the last node first, perform the addition with carry, and propagate the carry backwards.

- Using a recursive function, traverse to the end of the linked list
- Add 1 to the last node and propagate any resulting carry backwards through the recursive calls.
- At each step, add the carry to the current node's value and update the carry.
- Once recursion completes, if a carry still remains, create a new node at the beginning of the list with value 1.
- Return the updated head of the list.

![Image 1](https://static.takeuforward.org/content/1.png-IYtLApte)

![Image 2](https://static.takeuforward.org/content/2.png-ET-ME5sZ)

![Image 3](https://static.takeuforward.org/content/3.png-8W8MHU1Y)

![Image 4](https://static.takeuforward.org/content/4.png-RXLXwd_C)

![Image 5](https://static.takeuforward.org/content/5.png-cXlUjcx7)

![Image 6](https://static.takeuforward.org/content/6.png-79wkVwSv)

![Image 1](https://static.takeuforward.org/content/1.png-IYtLApte)![Image 2](https://static.takeuforward.org/content/2.png-ET-ME5sZ)![Image 3](https://static.takeuforward.org/content/3.png-8W8MHU1Y)![Image 4](https://static.takeuforward.org/content/4.png-RXLXwd_C)![Image 5](https://static.takeuforward.org/content/5.png-cXlUjcx7)![Image 6](https://static.takeuforward.org/content/6.png-79wkVwSv)

Code

C++JavaPythonJavaScript

```java
// Node class representing a single digit in the linked list
class Node {
    int data;
    Node next;

    Node(int value) {
        data = value;
        next = null;
    }
}

// LinkedList class having only append and print logic
class LinkedList {
    // Function to insert digit at the end
    Node append(Node head, int value) {
        Node newNode = new Node(value);
        if (head == null) {
            return newNode;
        }
        Node current = head;
        while (current.next != null)
            current = current.next;
        current.next = newNode;
        return head;
    }

    // Function to print the list
    void printList(Node head) {
        Node current = head;
        while (current != null) {
            System.out.print(current.data);
            current = current.next;
        }
        System.out.println();
    }
}

// Solution class having the addOne logic
class Solution {
    // Recursive function to add one from least significant digit (rightmost node)
    int addOneUtil(Node node) {
        // Base case: when reaching beyond last node, return carry = 1
        if (node == null) return 1;

        // Recurse to the end
        int carry = addOneUtil(node.next);  
        int sum = node.data + carry;
        node.data = sum % 10;
        // Return new carry
        return sum / 10;  
    }

    // Function to add one to the number represented by the linked list
    Node addOne(Node head) {
        // Perform recursive addition
        int carry = addOneUtil(head);

        // If carry remains after processing the head, create a new head node
        if (carry != 0) {
            Node newHead = new Node(carry);
            newHead.next = head;
            head = newHead;
        }

        return head;
    }
}

// Main class to run the program
public class Main {
    public static void main(String[] args) {
        Node head = null;
        LinkedList ll = new LinkedList();
        Solution sol = new Solution();

        // Example: Number 129 (1 -> 2 -> 9)
        head = ll.append(head, 1);
        head = ll.append(head, 2);
        head = ll.append(head, 9);

        System.out.print("Original Number: ");
        ll.printList(head);

        head = sol.addOne(head);

        System.out.print("After Adding One: ");
        ll.printList(head);
    }
}
```
Complexity Analysis

**Time Complexity: O(n)**, One pass for addition.  
**Space Complexity: O(n)**, Auxiliary stack space.

