
Length of Loop in Linked List

**Problem Statement:** Given the head of a linked list, determine the length of a loop present in the linked list. If there's no loop present, return 0.

**Examples**

Input: 

![](https://static.takeuforward.org/content/-mNCMyUW9)

Output: 3Explanation: A cycle exists in the linked list starting at node 3 -> 4 -> 5 and then back to 3. There are 3 nodes present in this cycle.

Input: 

![](https://static.takeuforward.org/content/-F-5I_yOu)

Output: 0Explanation: The linked list is linear and does not have a loop hence return 0.

Brute Force Approach

Algorithm

While traversing the linked list, employ a timer against each node to keep track of the number of nodes you've visited before it. Once a previously visited node is encountered again, the length of the loop can be determined by subtracting the timer values at the two instances of visiting that particular node.  
  
It's important to keep track of nodes and the timer value associated with them. This can be implemented using a hashmap with nodes as the key and the timer as the value.

![](https://static.takeuforward.org/content/-ngrN-xH1)

- Initialize a temporary pointer to head which will be used to traverse the list. While traversing, keep track of the Visited nodes and the timer value associated in the map data structure.
- Continue traversing till a node that has already been visited is found. The difference between its timer value in the hashmap and the current timers value will be the length of loop in the linked list.
- If the traversal is completed, and we reach the last point of the linked list which is null, it means there was no loop, hence we return 0.

![Image 1](https://static.takeuforward.org/content/s1.png-2qP1kIf9)

![Image 2](https://static.takeuforward.org/content/s2.png-PxFG3Fz8)

![Image 3](https://static.takeuforward.org/content/s3.png-FykR4htW)

![Image 4](https://static.takeuforward.org/content/s4.png-XgKWtj2j)

![Image 5](https://static.takeuforward.org/content/s5.png-05evGwli)

![Image 6](https://static.takeuforward.org/content/s6.png-FTN5LMSC)

![Image 7](https://static.takeuforward.org/content/s7.png-4B9XLJJS)

![Image 8](https://static.takeuforward.org/content/s8.png-FRaq12kE)

![Image 9](https://static.takeuforward.org/content/s9.png-OMca1RxC)

![Image 10](https://static.takeuforward.org/content/s10.png-qBxplrmB)

![Image 1](https://static.takeuforward.org/content/s1.png-2qP1kIf9)![Image 2](https://static.takeuforward.org/content/s2.png-PxFG3Fz8)![Image 3](https://static.takeuforward.org/content/s3.png-FykR4htW)![Image 4](https://static.takeuforward.org/content/s4.png-XgKWtj2j)![Image 5](https://static.takeuforward.org/content/s5.png-05evGwli)![Image 6](https://static.takeuforward.org/content/s6.png-FTN5LMSC)![Image 7](https://static.takeuforward.org/content/s7.png-4B9XLJJS)![Image 8](https://static.takeuforward.org/content/s8.png-FRaq12kE)![Image 9](https://static.takeuforward.org/content/s9.png-OMca1RxC)![Image 10](https://static.takeuforward.org/content/s10.png-qBxplrmB)

Code

```cpp
#include <bits/stdc++.h>
using namespace std;

// Node class represents a node in a linked list
class Node {
public:
    // Data stored in the node
    int data;

    // Pointer to the next node
    Node* next;

    // Constructor with both data and next node
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Solution class containing the loop length function
class Solution {
public:
    // Function to return the length of loop using hashing
    int lengthOfLoop(Node* head) {
        // Hashmap to store visited nodes and their timer values
        unordered_map<Node*, int> visitedNodes;

        // Pointer to traverse the linked list
        Node* temp = head;

        // Timer to track visited nodes
        int timer = 0;

        // Traverse the linked list till temp reaches nullptr
        while (temp != NULL) {
            // If revisiting a node, return the difference of timer values
            if (visitedNodes.find(temp) != visitedNodes.end()) {
                // Calculate the length of the loop
                int loopLength = timer - visitedNodes[temp];

                // Return the length of the loop
                return loopLength;
            }

            // Store the current node and its timer value
            visitedNodes[temp] = timer;

            // Move to the next node
            temp = temp->next;

            // Increment the timer
            timer++;
        }

        // If traversal is completed and we reach the end of the list
        // means there is no loop
        return 0;
    }
};

// Main driver function
int main() {
    // Creating a sample linked list with a loop
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);
    Node* fourth = new Node(4);
    Node* fifth = new Node(5);

    // Linking the nodes
    head->next = second;
    second->next = third;
    third->next = fourth;
    fourth->next = fifth;

    // Creating a loop from fifth to second
    fifth->next = second;

    // Creating a Solution object
    Solution obj;

    // Getting the loop length
    int loopLength = obj.lengthOfLoop(head);

    // Printing the result
    if (loopLength > 0) {
        cout << "Length of the loop: "
             << loopLength << endl;
    } else {
        cout << "No loop found in the linked list."
             << endl;
    }

    return 0;
}
```
Complexity Analysis**Time Complexity: O(N)**, we traverse the entire linked list atleast once to find the length of the loop.  
**Space Complexity: O(N)** , we use a map to store the timers for the nodes in the linked list.  

Optimal Approach

Algorithm

The previous method uses additional memory in order to find length of the loop. To enhance efficiency, the [Tortoise and Hare Algorithm](https://takeuforward.org/data-structure/find-middle-element-in-a-linked-list/) is introduced as an optimization.

- Initialise two pointers, slow and fast, to the head of the linked list. Slow will advance one step at a time, while fast will advance two steps at a time. These pointers will move simultaneously.
- Traverse the linked list with the slow and fast pointers. While traversing, repeatedly move slow one step and fast two steps at a time.
- Continue this traversal until either fast (or next node of fast) reaches null or both the pointers, slow and fast, meet.

![Image 1](https://static.takeuforward.org/content/sa1.png-SApH0IO3)

![Image 2](https://static.takeuforward.org/content/sa2.png-tNrNXm4E)

![Image 3](https://static.takeuforward.org/content/sa3.png-DxFhmTd8)

![Image 4](https://static.takeuforward.org/content/sa4.png-unGw_kbj)

![Image 5](https://static.takeuforward.org/content/sa5.png-aK25Ve58)

![Image 6](https://static.takeuforward.org/content/sa6.png-CGMS83sT)

![Image 7](https://static.takeuforward.org/content/sa7.png-fk2Gwk8x)

![Image 8](https://static.takeuforward.org/content/sa8.png-NYeQTR8k)

![Image 1](https://static.takeuforward.org/content/sa1.png-SApH0IO3)![Image 2](https://static.takeuforward.org/content/sa2.png-tNrNXm4E)![Image 3](https://static.takeuforward.org/content/sa3.png-DxFhmTd8)![Image 4](https://static.takeuforward.org/content/sa4.png-unGw_kbj)![Image 5](https://static.takeuforward.org/content/sa5.png-aK25Ve58)![Image 6](https://static.takeuforward.org/content/sa6.png-CGMS83sT)![Image 7](https://static.takeuforward.org/content/sa7.png-fk2Gwk8x)![Image 8](https://static.takeuforward.org/content/sa8.png-NYeQTR8k)

- This is the point where the slow and fast have met proving that there is a loop in the linked list. From here onwards we start counting for the length of this loop.
- Initialise a counter with zero and traverse the linked list using the slow pointer again while incrementing the counter with each node visited.

![Image 1](https://static.takeuforward.org/content/sb1.png-Rm0V-O-8)

![Image 2](https://static.takeuforward.org/content/sb2.png-SbskDvgX)

![Image 3](https://static.takeuforward.org/content/sb3.png-Umo0ocIo)

![Image 4](https://static.takeuforward.org/content/sb4.png-RcMf9EqN)

![Image 5](https://static.takeuforward.org/content/sb5.png-3yf8CamE)

![Image 6](https://static.takeuforward.org/content/sb6.png-XdwtvqHo)

![Image 7](https://static.takeuforward.org/content/sb7.png-oatbnuEj)

![Image 8](https://static.takeuforward.org/content/sb8.png-TFGnrGJ5)

![Image 1](https://static.takeuforward.org/content/sb1.png-Rm0V-O-8)![Image 2](https://static.takeuforward.org/content/sb2.png-SbskDvgX)![Image 3](https://static.takeuforward.org/content/sb3.png-Umo0ocIo)![Image 4](https://static.takeuforward.org/content/sb4.png-RcMf9EqN)![Image 5](https://static.takeuforward.org/content/sb5.png-3yf8CamE)![Image 6](https://static.takeuforward.org/content/sb6.png-XdwtvqHo)![Image 7](https://static.takeuforward.org/content/sb7.png-oatbnuEj)![Image 8](https://static.takeuforward.org/content/sb8.png-TFGnrGJ5)

- As the slow pointer reaches back at the fast pointer, the value of the counter will represent the length of the loop.

Code

```cpp
#include <bits/stdc++.h>
using namespace std;

// Node class represents a node in a linked list
class Node {
public:
    // Data stored in the node
    int data;

    // Pointer to the next node
    Node* next;

    // Constructor with both data and next node
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Solution class containing the loop length function
class Solution {
public:
    // Function to return the length of loop using Floyd's Algorithm
    int lengthOfLoop(Node* head) {
        // Initialize slow and fast pointers
        Node* slow = head;
        Node* fast = head;

        // Loop until fast and slow meet
        while (fast != NULL && fast->next != NULL) {
            // Move slow by one step
            slow = slow->next;

            // Move fast by two steps
            fast = fast->next->next;

            // If slow and fast meet, loop detected
            if (slow == fast) {
                // Count the length of the loop
                return countLoopLength(slow);
            }
        }

        // No loop found
        return 0;
    }

    // Function to count loop length
    int countLoopLength(Node* meetingPoint) {
        // Start from meeting point
        Node* temp = meetingPoint;
        int length = 1;

        // Move until we meet again
        while (temp->next != meetingPoint) {
            temp = temp->next;
            length++;
        }
        return length;
    }
};

// Main driver function
int main() {
    // Creating a sample linked list with a loop
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);
    Node* fourth = new Node(4);
    Node* fifth = new Node(5);

    // Linking the nodes
    head->next = second;
    second->next = third;
    third->next = fourth;
    fourth->next = fifth;

    // Creating a loop from fifth to second
    fifth->next = second;

    // Creating a Solution object
    Solution obj;

    // Getting the loop length
    int loopLength = obj.lengthOfLoop(head);

    // Printing the result
    if (loopLength > 0) {
        cout << "Length of the loop: "
             << loopLength << endl;
    } else {
        cout << "No loop found in the linked list."
             << endl;
    }

    return 0;
}
```
Complexity Analysis**Time Complexity: O(N)**, we traverse the entire linked list atleast once to find the length of the loop.  
**Space Complexity: O(1)** , we use a constant amount of additional space, regardless of the linked list's length to find the length of the loop.