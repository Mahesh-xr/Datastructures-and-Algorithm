
Reverse a Linked List



**Problem Statement:** Given the head of a singly linked list, write a program to reverse the linked list, and return the head pointer to the reversed list.

**Examples**

**Input**-  LL: 1   3   2   4 
**Output**: 3
**Explanation**: After reversing the linked list, the new head will point to the tail of the old linked list.

![](https://static.takeuforward.org/content/-ImQ2diyw)

Brute Force Approach

Algorithm

A straightforward approach to reversing a singly linked list is to use an additional data structure such as a stack. As we traverse the list, we push each node’s value onto the stack. Since stacks follow Last-In-First-Out (LIFO) order, popping elements from the stack gives us the values in reverse order. After the stack is filled, we reassign the values to the nodes while traversing the original list again. This effectively reverses the list in terms of values without modifying node links.

- Create an empty stack to store the node values of the original linked list.
- Traverse the linked list using a temporary pointer. For each node, push its value onto the stack.
- Reset the temporary pointer to the head of the list.
- While the stack is not empty, pop a value and assign it to the current node’s value. Move the pointer to the next node.
- Once the traversal is complete, return the head of the modified linked list.

![Image 1](https://static.takeuforward.org/content/1.png-mmUf_glL)

![Image 2](https://static.takeuforward.org/content/2.png-mL2k0Ce3)

![Image 1](https://static.takeuforward.org/content/1.png-mmUf_glL)![Image 2](https://static.takeuforward.org/content/2.png-mL2k0Ce3)

Code

C++JavaPythonJavaScript

```java
import java.util.*;

// Definition for singly-linked list node
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) {
        val = x;
        next = null;
    }
}

class Solution {
    // Function to reverse a linked list using stack
    public ListNode reverseList(ListNode head) {
        // Stack to store values of nodes
        Stack<Integer> stack = new Stack<>();

        // Temporary pointer to traverse the list
        ListNode temp = head;

        // Traverse and push all node values to stack
        while (temp != null) {
            stack.push(temp.val);
            temp = temp.next;
        }

        // Reset temp back to head
        temp = head;

        // Reassign values from stack in reverse order
        while (temp != null) {
            temp.val = stack.pop();
            temp = temp.next;
        }

        // Return the modified head
        return head;
    }
}

// Driver code
class Main {
    public static void main(String[] args) {
        // Creating linked list 1 -> 2 -> 3 -> null
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);

        Solution sol = new Solution();
        head = sol.reverseList(head);

        // Printing reversed list
        while (head != null) {
            System.out.print(head.val + " ");
            head = head.next;
        }
    }
}
```
Complexity Analysis

**Time Complexity:** O(N) ,We traverse the linked list twice once to push all node values into the stack, and once to reassign values. Each traversal takes O(N) time, where N is the number of nodes.

**Space Complexity:** O(N) , We use an extra stack to store all the node values, which requires O(N) additional space.

Optimal Approach

Algorithm

The core idea is to change the next pointers of the nodes one by one so that they point backward instead of forward. By maintaining references to the current node, its previous node, and the next node, we can safely rewire the links without losing track of the list. Once all links are reversed, the last node of the original list becomes the new head.

- Initialize a traversal pointer at the head of the linked list.
- Also initialize a pointer for the previous node and set it to NULL.
- Repeat the following steps until the traversal pointer reaches the end:

- Save the next node in a temporary pointer.
- Reverse the `next` pointer of the current node to point to the previous node.
- Move the previous pointer to the current node.
- Advance the traversal pointer to the next node (saved earlier).

- Once the traversal is complete, return the previous node as the new head of the reversed list.

![Image 1](https://static.takeuforward.org/content/1.png-tsrDUu6W)

![Image 2](https://static.takeuforward.org/content/2.png-tDwDLtYi)

![Image 1](https://static.takeuforward.org/content/1.png-tsrDUu6W)![Image 2](https://static.takeuforward.org/content/2.png-tDwDLtYi)

Code

C++JavaPythonJavaScript

```java
// Definition for singly-linked list node
class ListNode {
    int val;
    ListNode next;

    // Constructor to initialize node value
    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

class Solution {
    // Function to reverse a linked list iteratively
    public ListNode reverseList(ListNode head) {
        // Initialize previous pointer to null
        ListNode prev = null;

        // Start from the head of the list
        ListNode temp = head;

        // Traverse the list
        while (temp != null) {
            // Save the next node
            ListNode front = temp.next;

            // Reverse the current node's pointer
            temp.next = prev;

            // Move prev to current node
            prev = temp;

            // Move to the next node
            temp = front;
        }

        // Return new head (last node becomes first)
        return prev;
    }
}

// Driver class
public class Main {
    public static void main(String[] args) {
        // Creating a linked list: 1 -> 2 -> 3 -> 4 -> 5
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);

        Solution sol = new Solution();
        // Reversing the list
        ListNode newHead = sol.reverseList(head);

        // Printing the reversed list
        while (newHead != null) {
            System.out.print(newHead.val + " ");
            newHead = newHead.next;
        }
        System.out.println();
    }
}
```
Complexity Analysis

**Time Complexity:** O(N) Because we are traversing each node of the linked list exactly once. Each pointer reversal is done in constant time.

**Space Complexity:** O(1) We are not using any additional data structure or recursion. All modifications are done in-place using pointers.

Recursive Approach

Algorithm

Before diving into this approach, make sure your concepts of recursion are solid. Recursion lets us break a problem into smaller subproblems and solve them incrementally. It continues doing this until it hits the base case, the smallest instance of the problem. From there, it starts combining the results of the subproblems to solve the original task.  
  
In the case of reversing a singly linked list: We're reducing the problem from reversing N nodes to reversing N - 1, N - 2, and so on. When we hit the base case (1 node), we start wiring the reversed nodes back together.  
  
For example, if the list has 4 nodes:  
Recursion works down from 4 → 3 → 2 → 1.  
Then it rewires the links backward starting from node 1.

- **Base Case:** If the head is `null` or there’s only one node, it’s already reversed. So, just return the head.
- **Recursive Step:** Call the same function to reverse the rest of the list starting from `head.next`. This recursive call gives back the new head of the reversed sublist.
- **Store Reference:** Before breaking any link, store the next node (say `front`) so we don’t lose access to it.
- **Reverse the Link:** Now, set `front.next = head`. This flips the direction of the link — making the next node point back to the current one.
- **Break the Old Link:** To avoid cycles, disconnect the original forward link by doing `head.next = null`.
- **Return the New Head:** Finally, return the `newHead` received from the recursive call — it’s now the head of the reversed list.

![](https://static.takeuforward.org/content/-Vl7WwoJV)

Code

C++JavaPythonJavaScript

```java
import java.util.*;
// Definition for singly-linked list node
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; next = null; }
}

class Solution {
    // Recursive method to reverse linked list
    public ListNode reverseList(ListNode head) {
        // Base case: if list is empty or has only one node
        if (head == null || head.next == null)
            return head;

        // Recursively reverse the rest of the list
        ListNode newHead = reverseList(head.next);

        // Store reference to next node
        ListNode front = head.next;

        // Make the next node point to current node
        front.next = head;

        // Break original forward link
        head.next = null;

        // Return new head of reversed list
        return newHead;
    }
}

// Driver code
class Main {
    public static void main(String[] args) {
        // Creating linked list: 1 -> 2 -> 3 -> 4 -> 5
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);

        Solution sol = new Solution();
        ListNode reversed = sol.reverseList(head);

        // Printing reversed list
        while (reversed != null) {
            System.out.print(reversed.val + " ");
            reversed = reversed.next;
        }
        System.out.println();
    }
}
```
Complexity Analysis

**Time Complexity:** O(n),Each node is visited exactly once during the recursive call, and we do constant-time work for each node (like flipping pointers).

**Space Complexity:** O(n),The recursion stack goes up to n levels deep (one for each node), which uses extra space on the call stack.