
**Problem Statement:** Given a linked list containing only 0's, 1's, and 2's, sort the linked list by rearranging the links (not by changing the data values).

**Examples**

Input: 1 -> 2 -> 0 -> 1 -> 0 -> 2 -> NULLOutput: 0 -> 0 -> 1 -> 1 -> 2 -> 2 -> NULLInput: 2 -> 1 -> 2 -> 0 -> 0 -> 1 -> NULLOutput: 0 -> 0 -> 1 -> 1 -> 2 -> 2 -> NULL

Approach

Algorithm

Instead of sorting by swapping data values, we need to rearrange the actual links. The key insight is to maintain three separate chains for 0's, 1's, and 2's, then connect them at the end.

- We traverse the original list once, and for each node:
- If value is 0, add it to the "zero's" chain
- If value is 1, add it to the "one's" chain
- If value is 2, add it to the "two's" chain
- Finally, we connect zero's chain to one's chain and then one's chain to two's chain
- Handle edge cases where any chain might be empty

![Image 1](https://static.takeuforward.org/content/1.png-P2SJ7iPe)

![Image 2](https://static.takeuforward.org/content/2.png-ylbUpn8m)

![Image 3](https://static.takeuforward.org/content/3.png-4sh5ylDm)

![Image 4](https://static.takeuforward.org/content/4.png-_Gk8w-Xx)

![Image 5](https://static.takeuforward.org/content/5.png-KBi1gM9r)

![Image 6](https://static.takeuforward.org/content/6.png-sHz86Kwt)

![Image 7](https://static.takeuforward.org/content/7.png-RX2HutcX)

![Image 8](https://static.takeuforward.org/content/8.png-e1wOn-pK)

![Image 9](https://static.takeuforward.org/content/9.png-Y8mPZ8Wy)

![Image 1](https://static.takeuforward.org/content/1.png-P2SJ7iPe)![Image 2](https://static.takeuforward.org/content/2.png-ylbUpn8m)![Image 3](https://static.takeuforward.org/content/3.png-4sh5ylDm)![Image 4](https://static.takeuforward.org/content/4.png-_Gk8w-Xx)![Image 5](https://static.takeuforward.org/content/5.png-KBi1gM9r)![Image 6](https://static.takeuforward.org/content/6.png-sHz86Kwt)![Image 7](https://static.takeuforward.org/content/7.png-RX2HutcX)![Image 8](https://static.takeuforward.org/content/8.png-e1wOn-pK)![Image 9](https://static.takeuforward.org/content/9.png-Y8mPZ8Wy)

Code

C++JavaPythonJavaScript

```java
// Node class representing each element of the linked list
class Node {
    int data;
    Node next;

    // Constructor to initialize node with a value
    Node(int val) {
        data = val;
        next = null;
    }
}

// LinkedList class to manage list operations
class LinkedList {
    Node head;

    // Constructor to initialize an empty list
    LinkedList() {
        head = null;
    }

    // Function to insert a new node at the end
    void insert(int val) {
        Node newNode = new Node(val);
        if (head == null) {
            head = newNode; 
            return;
        }
        Node temp = head;
        while (temp.next != null)
            temp = temp.next;
        temp.next = newNode;
    }

    // Function to print the entire linked list
    void print() {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data);
            if (temp.next != null) System.out.print(" -> ");
            temp = temp.next;
        }
        System.out.println(" -> NULL");
    }
}

// Solution class containing logic for sorting the list
class Solution {
    // Function to sort linked list of 0s, 1s, and 2s by rearranging the links
    void sortZeroOneTwo(LinkedList ll) {
        // Create dummy nodes for 0s, 1s, and 2s
        Node zeroDummy = new Node(-1);
        Node oneDummy = new Node(-1);
        Node twoDummy = new Node(-1);

        // Create tail pointers to add new nodes in respective lists
        Node zeroTail = zeroDummy;
        Node oneTail = oneDummy;
        Node twoTail = twoDummy;

        Node curr = ll.head;

        // Traverse the original list
        while (curr != null) {
            if (curr.data == 0) {
                zeroTail.next = curr;
                zeroTail = zeroTail.next;
            } else if (curr.data == 1) {
                oneTail.next = curr;
                oneTail = oneTail.next;
            } else {
                twoTail.next = curr;
                twoTail = twoTail.next;
            }
            curr = curr.next;
        }

        // Connect 0s list to 1s, and 1s to 2s
        zeroTail.next = (oneDummy.next != null) ? oneDummy.next : twoDummy.next;
        oneTail.next = twoDummy.next;
        twoTail.next = null;

        // Update original list head
        ll.head = zeroDummy.next;
    }
}

// Main class to run the code
public class Main {
    public static void main(String[] args) {
        LinkedList ll = new LinkedList();
        Solution sol = new Solution();

        // Inserting nodes into linked list
        ll.insert(1);
        ll.insert(2);
        ll.insert(0);
        ll.insert(1);
        ll.insert(2);
        ll.insert(0);

        System.out.println("Original List:");
        ll.print();

        // Sorting the list
        sol.sortZeroOneTwo(ll);

        System.out.println("Sorted List:");
        ll.print();
    }
}
```
Complexity Analysis**Time Complexity:** O(n), We traverse the entire list once.  
**Space Complexity:** O(1), Only dummy nodes and pointers are used (constant space).  

