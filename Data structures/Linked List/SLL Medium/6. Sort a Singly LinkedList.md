

**Problem Statement:** Given a linked list, sort its nodes based on the data value in them. Return the head of the sorted linked list.

**Examples**

Input: 3->4->2->1->5 

![](https://static.takeuforward.org/content/---7NAX7F)

Output: 1->2->3->4->5

![](https://static.takeuforward.org/content/-121jziNF)

Explanation: The input linked list when sorted from [3, 4, 2, 1, 5] results in a linked list with values [1, 2, 3, 4, 5].

Input: 40->20->60->10->50->30

![](https://static.takeuforward.org/content/-au7rx4rP)

Output: 10->20->30->40->50->60

![](https://static.takeuforward.org/content/-lGFKV4JR)

Explanation: The input linked list when sorted from [40, 20, 60, 10, 50, 30] results in a linked list with values [10, 20, 30, 40, 50, 60].

Brute-Force Approach

Algorithm

To sort a given linked list, we can simply create an array of all the elements of the linked list. Now, we can sort this array using any sorting technique and reassign the values of the sorted array to our linked list. This modified linked list will have all the elements in sorted order.

- Create an empty array to store the node values. Iterate the linked list using a temporary pointer to the head and push the value of temporary node into the array.
- Sort the array containing node values in ascending order.
- Convert the sorted array back to a linked list reassigning the values from the sorted array and overwriting them sequentially according to their order in the array.

![Image 1](https://static.takeuforward.org/content/s1.png-hUjBxYdb)

![Image 2](https://static.takeuforward.org/content/s2.png-FxIiA4Lm)

![Image 3](https://static.takeuforward.org/content/s3.png-N3S0M4QT)

![Image 1](https://static.takeuforward.org/content/s1.png-hUjBxYdb)![Image 2](https://static.takeuforward.org/content/s2.png-FxIiA4Lm)![Image 3](https://static.takeuforward.org/content/s3.png-N3S0M4QT)

Code

C++JavaPythonJavaScript

```java
import java.util.*;

// Node class represents a linked list node
class Node {
    // Data stored in the node
    int data;

    // Pointer to the next node
    Node next;

    // Constructor with data and next pointer
    Node(int data1, Node next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data
    Node(int data1) {
        data = data1;
        next = null;
    }
}

// Solution class to hold sorting function
class Solution {
    // Function to sort the linked list
    public Node sortLL(Node head) {
        // List to store node values
        ArrayList<Integer> arr = new ArrayList<>();

        // Pointer to traverse the list
        Node temp = head;

        // Traverse and push values into list
        while (temp != null) {
            arr.add(temp.data);
            temp = temp.next;
        }

        // Sort the list
        Collections.sort(arr);

        // Reassign sorted values to list nodes
        temp = head;
        for (int i = 0; i < arr.size(); i++) {
            temp.data = arr.get(i);
            temp = temp.next;
        }

        // Return head of sorted list
        return head;
    }
}

// Main class to run the program
public class Main {
    // Function to print linked list
    static void printLinkedList(Node head) {
        // Pointer to traverse list
        Node temp = head;

        // Traverse and print values
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create linked list: 3 -> 2 -> 5 -> 4 -> 1
        Node head = new Node(3);
        head.next = new Node(2);
        head.next.next = new Node(5);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(1);

        // Print original list
        System.out.print("Original Linked List: ");
        printLinkedList(head);

        // Create Solution object
        Solution obj = new Solution();

        // Sort the linked list
        head = obj.sortLL(head);

        // Print sorted list
        System.out.print("Sorted Linked List: ");
        printLinkedList(head);
    }
}
```
Complexity Analysis**Time Complexity: O(2*N + N*LogN)**, we traverse the linked list, store its elements in an array, sort it, and then copy the sorted values back into the original list.  
**Space Complexity: O(N)** , additional space required to store all the elements of linked list in an array.  

Optimal Approach

Algorithm

Instead of using an external array to store node values, we can try to implement similar sorting techniques for linked lists as well. In order to sort the linked list, we can try to implement a modified version of [Merge Sort Algorithm](https://takeuforward.org/data-structure/merge-sort-algorithm/). This algorithm would divide the linked list into halves recursively until single nodes remain. These sorted halves of the linked list are merged back together in a sorted order.

- If the linked list is empty or has only one node, it is already sorted, thus we can return the head directly.
- Use the slow and fast pointer technique to find the middle of the linked list, where slow moves one step and fast moves two steps at a time.
- Split the linked list into two halves at the midpoint by pointing middle to null, where the left half starts from the head and the right half starts from the node after the middle.
- Recursively apply merge sort on both halves of the linked list until each part is broken down into single nodes or empty lists.
- Merge the two sorted halves using a helper function that compares node values from both halves, attaches the smaller one to the result list, and continues until all nodes from both halves are merged.
- Return the head of the merged and fully sorted linked list, which will represent the final sorted list.

![Image 1](https://static.takeuforward.org/content/sb1.png-mGNelxtc)

![Image 2](https://static.takeuforward.org/content/sb22.png-9Fb0_Ylq)

![Image 1](https://static.takeuforward.org/content/sb1.png-mGNelxtc)![Image 2](https://static.takeuforward.org/content/sb22.png-9Fb0_Ylq)

Code

C++JavaPythonJavaScript

```java
import java.util.*;

// Node class represents a linked list node
class Node {
    // Data stored in the node
    int data;

    // Pointer to the next node
    Node next;

    // Constructor with data and next pointer
    Node(int data1, Node next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data
    Node(int data1) {
        data = data1;
        next = null;
    }
}

// Solution class contains merge sort logic
class Solution {
    // Function to merge two sorted linked lists
    public Node mergeTwoSortedLinkedLists(Node list1, Node list2) {
        // Create a dummy node
        Node dummyNode = new Node(-1, null);

        // Temp pointer to build merged list
        Node temp = dummyNode;

        // Traverse both lists
        while (list1 != null && list2 != null) {
            // Choose smaller node
            if (list1.data <= list2.data) {
                temp.next = list1;
                list1 = list1.next;
            } else {
                temp.next = list2;
                list2 = list2.next;
            }
            // Move temp pointer
            temp = temp.next;
        }

        // Attach remaining nodes
        if (list1 != null) {
            temp.next = list1;
        } else {
            temp.next = list2;
        }

        // Return head of merged list
        return dummyNode.next;
    }

    // Function to find middle of linked list
    public Node findMiddle(Node head) {
        // If list empty or single node
        if (head == null || head.next == null) {
            return head;
        }

        // Slow and fast pointers
        Node slow = head;
        Node fast = head.next;

        // Move fast twice as fast as slow
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Return middle node
        return slow;
    }

    // Function to perform merge sort
    public Node sortLL(Node head) {
        // Base case: empty or single node
        if (head == null || head.next == null) {
            return head;
        }

        // Find middle node
        Node middle = findMiddle(head);

        // Split into two halves
        Node right = middle.next;
        middle.next = null;
        Node left = head;

        // Recursively sort both halves
        left = sortLL(left);
        right = sortLL(right);

        // Merge sorted halves
        return mergeTwoSortedLinkedLists(left, right);
    }
}

// Main class to run the program
public class Main {
    // Function to print linked list
    static void printLinkedList(Node head) {
        // Temp pointer to traverse
        Node temp = head;

        // Traverse and print nodes
        while (temp != null) {
            System.out.print(temp.data + " ");
            temp = temp.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create linked list: 3 -> 2 -> 5 -> 4 -> 1
        Node head = new Node(3, null);
        head.next = new Node(2, null);
        head.next.next = new Node(5, null);
        head.next.next.next = new Node(4, null);
        head.next.next.next.next = new Node(1, null);

        // Print original list
        System.out.print("Original Linked List: ");
        printLinkedList(head);

        // Create Solution object
        Solution obj = new Solution();

        // Sort the linked list
        head = obj.sortLL(head);

        // Print sorted list
        System.out.print("Sorted Linked List: ");
        printLinkedList(head);
    }
}
```
Complexity Analysis**Time Complexity: O(N*LogN)**, we recursively divide the linked list into two halves and then merge two sorted halves.  
**Space Complexity: O(1)** , constant additional space is required to sort the entire linked list.