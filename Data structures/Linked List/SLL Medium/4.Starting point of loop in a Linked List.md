
Starting point of loop in a Linked List



**Problem Statement:** Given the head of a linked list that may contain a cycle, return the starting point of that cycle. If there is no cycle in the linked list return null.

**Examples**

**Input:** LL: 1  2  3  4  5
**Output:** 3
**Explanation:** This linked list contains a loop of size 3 starting at node with value 3.
![](https://static.takeuforward.org/content/-cjFJd-b0)  
**Input:** LL: 1 -> 2 -> 3 -> 4 -> 9 -> 9
**Output:**NULL
**Explanation:** This linked list does not contain a loop hence has no starting point
![](https://static.takeuforward.org/content/-TctgXbon)

Brute Force Approach

Algorithm

The starting point of a loop of the linked list is the first node we visit twice during its traversal. It's the point where we realise that we are no longer moving forward in the list but rather entering a cycle.

- Traverse through the linked list by assigning a temporary node to the head and moving to the next node repeatedly until reaching null.
- While traversing, keep a record of visited nodes using a map data structure.
- Storing the entire node in the map is necessary to differentiate between nodes with the same value but different positions, ensuring proper detection of cycles instead of just duplicates.
- If a node already exists in the map, this confirms a loop, and we return that node as the starting point of the loop.
- If the traversal reaches the end of the list (null), it means no loop exists, so return null.

![Image 1](https://static.takeuforward.org/content/3.png-HTE0hNxb)

![Image 2](https://static.takeuforward.org/content/4.png-v8IGFo1i)

![Image 3](https://static.takeuforward.org/content/5.png-N5Qif0VD)

![Image 4](https://static.takeuforward.org/content/6.png-uJ86DHSR)

![Image 5](https://static.takeuforward.org/content/7.png-K0KhGmH9)

![Image 6](https://static.takeuforward.org/content/8.png-_wxPoKo-)

![Image 7](https://static.takeuforward.org/content/9.png-8MbCYkOV)

![Image 1](https://static.takeuforward.org/content/3.png-HTE0hNxb)![Image 2](https://static.takeuforward.org/content/4.png-v8IGFo1i)![Image 3](https://static.takeuforward.org/content/5.png-N5Qif0VD)![Image 4](https://static.takeuforward.org/content/6.png-uJ86DHSR)![Image 5](https://static.takeuforward.org/content/7.png-K0KhGmH9)![Image 6](https://static.takeuforward.org/content/8.png-_wxPoKo-)![Image 7](https://static.takeuforward.org/content/9.png-8MbCYkOV)

Code

C++JavaPythonJavaScript

```java
import java.util.*;

class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
        next = null;
    }
}

class Solution {
    // Function to detect start of loop using Hash Map
    public ListNode detectCycle(ListNode head) {
        // Create a set to store visited nodes
        Set<ListNode> visited = new HashSet<>();

        // Traverse through the list
        while (head != null) {
            // If already visited, it's the start of the loop
            if (visited.contains(head)) {
                return head;
            }

            // Mark current node as visited
            visited.add(head);

            // Move to the next node
            head = head.next;
        }

        // No cycle found
        return null;
    }
}

public class Main {
    public static void main(String[] args) {
        // Creating linked list nodes
        ListNode head = new ListNode(3);
        head.next = new ListNode(2);
        head.next.next = new ListNode(0);
        head.next.next.next = new ListNode(-4);

        // Creating a cycle (tail connects to node index 1)
        head.next.next.next.next = head.next;

        Solution obj = new Solution();
        ListNode startNode = obj.detectCycle(head);

        if (startNode != null)
            System.out.println("Cycle starts at node with value: " + startNode.val);
        else
            System.out.println("No cycle found.");
    }
}
```
Complexity Analysis

**Time Complexity:** O(N) where N is the number of nodes in the linked list. Each node is visited only once during traversal. Hashing allows O(1) lookup to check for previously visited nodes.

**Space Complexity:** O(N) due to the additional hash set used to store visited nodes. In the worst case (no cycle), all N nodes will be stored in the hash set.

Optimal Approach

Algorithm

The previous method uses O(N) additional memory, which can become quite large as the linked list length grows. To enhance efficiency, the Tortoise and Hare Algorithm is introduced as an optimization.  
  
The Tortoise and Hare approach has been discussed in this [article](https://takeuforward.org/data-structure/find-middle-element-in-a-linked-list/). The key insight is that when the slow and fast pointers meet inside the loop, the distance travelled by each pointer can be used to calculate the starting point of the loop.

![Image 1](https://static.takeuforward.org/content/10.png-EKIk5_PO)

![Image 2](https://static.takeuforward.org/content/11.png-RfeIfR6H)

![Image 3](https://static.takeuforward.org/content/12.png-QZujZl1a)

![Image 4](https://static.takeuforward.org/content/13.png-k53-zKhC)

![Image 5](https://static.takeuforward.org/content/14.png-46nb1EzL)

![Image 6](https://static.takeuforward.org/content/15.png-zLF78NqU)

![Image 7](https://static.takeuforward.org/content/16.png-KkmhW30C)

![Image 8](https://static.takeuforward.org/content/17.png-9XpBJfdU)

![Image 1](https://static.takeuforward.org/content/10.png-EKIk5_PO)![Image 2](https://static.takeuforward.org/content/11.png-RfeIfR6H)![Image 3](https://static.takeuforward.org/content/12.png-QZujZl1a)![Image 4](https://static.takeuforward.org/content/13.png-k53-zKhC)![Image 5](https://static.takeuforward.org/content/14.png-46nb1EzL)![Image 6](https://static.takeuforward.org/content/15.png-zLF78NqU)![Image 7](https://static.takeuforward.org/content/16.png-KkmhW30C)![Image 8](https://static.takeuforward.org/content/17.png-9XpBJfdU)

- Initialise two pointers, `slow` and `fast`, to the head of the linked list. `slow` will advance one step at a time, while `fast` will advance two steps at a time. These pointers will move simultaneously.
- Traverse the linked list with the `slow` and `fast` pointers. While traversing, repeatedly move `slow` one step and `fast` two steps at a time.
- Continue this traversal until one of the following conditions is met:
    1. `fast` or `fast.next` reaches the end of the linked list (i.e., becomes null). In this case, there is no loop in the linked list, and the algorithm terminates by returning null.
    2. `fast` and `slow` pointers meet at the same node. This indicates the presence of a loop in the linked list.
- Reset the `slow` pointer to the head of the linked list. Move `fast` and `slow` one step at a time until they meet again. The point where they meet again is the starting point of the loop.

  
**You may be curious about the proof for this algorithm, and it hinges on the idea that the point where the slow and fast pointers converge can be leveraged to determine the starting point of the loop.**  
  
In the "tortoise and hare" algorithm for detecting loops in a linked list, when the slow pointer (tortoise) reaches the starting point of the loop, the fast pointer (hare) is positioned at a point that is twice the distance travelled by the slow pointer. This is because the hare moves at double the speed of the tortoise.  
  
If slow has travelled distance L1 then fast has travelled 2 x L1. Now that slow and fast have entered the loop, the distance fast will have to cover to catch up to slow is the total length of loop minus L1. Let this distance be d. Distance travelled by slow = L1 Distance travelled by fast = 2 * L1 Total length of loop = L1 + d  
  
In this configuration, the fast pointer advances toward the slow pointer with two jumps per step, while the slow pointer moves away with one jump per step. As a result, the gap between them decreases by 1 with each step. Given that the initial gap is d, it takes exactly d steps for them to meet.  

 Total length of loop = L1 + d Distance between slow and fast = d 

![](https://static.takeuforward.org/content/-pnBkIbt4)  
  
During these d steps, the slow pointer effectively travels d steps from the starting point within the loop and fast travels 2 x d and they meet at a specific point. Based on our previous calculations, the total length of the loop is L1 + d. And since the distance covered by the slow pointer within the loop is d, the remaining distance within the loop is equal to L1.  
  
Therefore, it is proven that the distance between the starting point of the loop and the point where the two pointers meet is indeed equal to the distance between the starting point and head of the linked list.

![Image 1](https://static.takeuforward.org/content/19.png-Q8E1KGuH)

![Image 2](https://static.takeuforward.org/content/20.png-D9L7pl1P)

![Image 1](https://static.takeuforward.org/content/19.png-Q8E1KGuH)![Image 2](https://static.takeuforward.org/content/20.png-D9L7pl1P)

Code

C++JavaPythonJavaScript

```java
import.java.util.*;
    class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
        next = null;
    }
}

class Solution {
    // Function to detect the starting point of loop using Floyd’s algorithm
    public ListNode detectCycle(ListNode head) {
        // Initialize slow and fast pointers
        ListNode slow = head;
        ListNode fast = head;

        // Traverse while fast and fast.next are not null
        while (fast != null && fast.next != null) {
            // Move slow one step
            slow = slow.next;

            // Move fast two steps
            fast = fast.next.next;

            // If they meet, cycle is present
            if (slow == fast) {
                // Reset slow to head
                slow = head;

                // Move both one step to find start of loop
                while (slow != fast) {
                    slow = slow.next;
                    fast = fast.next;
                }

                // Return the starting node of loop
                return slow;
            }
        }

        // If no cycle found
        return null;
    }
}

public class Main {
    public static void main(String[] args) {
        // Create nodes
        ListNode head = new ListNode(3);
        head.next = new ListNode(2);
        head.next.next = new ListNode(0);
        head.next.next.next = new ListNode(-4);

        // Create cycle: last node connects to node with value 2
        head.next.next.next.next = head.next;

        Solution obj = new Solution();
        ListNode result = obj.detectCycle(head);

        if (result != null)
            System.out.println("Cycle starts at node with value: " + result.val);
        else
            System.out.println("No cycle found.");
    }
}
```
Complexity Analysis

**Time Complexity:** O(N) where N is the number of nodes in the linked list. In the worst case, we traverse the entire list once with the slow and fast pointers, and then again to find the entry point of the loop.

**Space Complexity:** O(1) constant extra space. No additional data structures are used, only two pointers.