
Reverse Words in a String

**Problem Statement:** Given an input string, containing upper-case and lower-case letters, digits, and spaces( ' ' ). A word is defined as a sequence of non-space characters. The words in s are separated by at least one space. Return a string with the words in reverse order, concatenated by a single space.

**Examples**

**Input:** s = "welcome to the jungle"
**Output:** "jungle the to welcome"
**Explanation:** The words in the input string are "welcome", "to", "the", and "jungle". Reversing the order of these words gives "jungle", "the", "to", and "welcome". The output string should have exactly one space between each word.  
**Input:** s = " amazing coding skills "
**Output:** "skills coding amazing"
**Explanation:** The input string has leading and trailing spaces, as well as multiple spaces between the words "amazing", "coding", and "skills". After trimming the leading and trailing spaces and reducing the multiple spaces between words to a single space, the words are "amazing", "coding", and "skills". Reversing the order of these words gives "skills", "coding", and "amazing". The output string should not have any leading or trailing spaces and should have exactly one space between each word.

Brute Force Approach

Algorithm

In the brute force method, we manually parse the string to extract words without directly using high-level split functions. The idea is to read through the string character by character, identify sequences of non-space characters as words, store them in a list, and then reverse the list to achieve the desired order. We also need to handle multiple spaces, leading spaces, and trailing spaces, which means ignoring extra spaces while collecting words. Once reversed, we join the words using a single space. This way, the output string has exactly one space between each word and no leading or trailing spaces.

- Initialize an empty list to store words.
- Traverse the string character by character.
- Identify consecutive non-space characters as a word.
- Ignore extra spaces and leading/trailing spaces while collecting words.
- Append each identified word to the list.
- Reverse the list of words.
- Join the reversed list into a single string using a single space.
- Return the resulting string.

![Image 1](https://static.takeuforward.org/content/brute1.png-RtKv5div)

![Image 2](https://static.takeuforward.org/content/brute2.png-rDW8d-jI)

![Image 1](https://static.takeuforward.org/content/brute1.png-RtKv5div)![Image 2](https://static.takeuforward.org/content/brute2.png-rDW8d-jI)

Code

C++JavaPythonJavaScript

```java
import java.util.*;

class Solution {
    // Function to reverse the order of words in a string
    public String reverseWords(String s) {
        // List to store words
        List<String> words = new ArrayList<>();
        
        // StringBuilder to store a single word
        StringBuilder word = new StringBuilder();
        
        // Traverse each character in the string
        for (int i = 0; i < s.length(); i++) {
            // If it's not a space, add it to current word
            if (s.charAt(i) != ' ') {
                word.append(s.charAt(i));
            } 
            // If space and a word is formed
            else if (word.length() > 0) {
                // Add word to list
                words.add(word.toString());
                // Reset word
                word.setLength(0);
            }
        }
        
        // Add the last word if present
        if (word.length() > 0) {
            words.add(word.toString());
        }
        
        // Reverse the list
        Collections.reverse(words);
        
        // Join with single space
        return String.join(" ", words);
    }
}

// Driver code
class Main {
    public static void main(String[] args) {
        Solution obj = new Solution();
        String s = " amazing coding skills ";
        System.out.println(obj.reverseWords(s));
    }
}
```
Complexity Analysis

**Time Complexity:** O(N),We traverse the string once to collect words (O(N)) and once more to reverse and join them (O(N)). Hence total time is O(N).

**Space Complexity:** O(N),We store all words in a separate list/array, requiring extra space proportional to the number of characters.

Optimal Approach

Algorithm

Instead of splitting into words and then reversing, we can scan the string from right to left and build the output directly. By starting at the end and identifying each word, we can append it to our result string immediately. We skip multiple spaces, handle leading/trailing spaces naturally, and avoid reversing the list separately which removes one extra pass. This reduces unnecessary data movement and avoids building a list to reverse later.

- Initialize an empty result string.
- Set a pointer at the last character of the string.
- While the pointer is within the string:

- Skip all spaces to move to the end of a word.
- Mark the end position of the word.
- Move the pointer backward until a space or start of string is found.
- Extract the word and append it to the result string.
- If result is not empty, add a space before appending the next word.

- Return the result string.

![Image 1](https://static.takeuforward.org/content/1.png-AjHo_7Wo)

![Image 2](https://static.takeuforward.org/content/2.png-rVgtFRhz)

![Image 1](https://static.takeuforward.org/content/1.png-AjHo_7Wo)![Image 2](https://static.takeuforward.org/content/2.png-rVgtFRhz)

Code

C++JavaPythonJavaScript

```java
class Solution {
    // Function to reverse the order of words 
    public String reverseWords(String s) {
        // StringBuilder for final result
        StringBuilder result = new StringBuilder();
        
        // Pointer starting from the end
        int i = s.length() - 1;
        
        // Traverse from right to left
        while (i >= 0) {
            // Skip spaces
            while (i >= 0 && s.charAt(i) == ' ') {
                i--;
            }
            
            // If pointer goes out of bounds, break
            if (i < 0) break;
            
            // Mark end of word
            int end = i;
            
            // Move left until space or start of string
            while (i >= 0 && s.charAt(i) != ' ') {
                i--;
            }
            
            // Extract the word
            String word = s.substring(i + 1, end + 1);
            
            // Add space before appending if result is not empty
            if (result.length() > 0) {
                result.append(" ");
            }
            
            // Append word
            result.append(word);
        }
        
        return result.toString();
    }
}

// Driver code
class Main {
    public static void main(String[] args) {
        Solution obj = new Solution();
        String s = " amazing coding skills ";
        System.out.println(obj.reverseWords(s));
    }
}
```
Complexity Analysis

**Time Complexity:** O(N), We traverse the string once from right to left and construct the result directly without extra passes.

**Space Complexity:** O(1),Ignoring the output string, no additional data structures proportional to input size are used.