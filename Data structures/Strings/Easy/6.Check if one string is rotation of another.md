
Check if one string is rotation of another

**Problem Statement:** Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.  
A shift on s consists of moving the leftmost character of s to the rightmost position. For example, if s = "abcde", then it will be "bcdea" after one shift.

**Examples**

**Example 1:****Input:** s = "rotation", goal = "tionrota"
**Output:** true
**Explanation:** After multiple left shifts on "rotation", we get:
    1st shift → "otationr"
    2nd shift → "tationro"
    3rd shift → "ationrot"
    4th shift → "tionrota"
    So the goal string can be obtained by rotating the original string.

**Example 2:****Input:** s = "hello", goal = "lohelx"
**Output:** false
**Explanation:** 
Even after all possible rotations of "hello", we cannot form "lohelx" due to the presence of an extra character 'x'. Hence, it's not possible.
            

Brute Force

Algorithm

- Start by generating all possible left rotations of the original string using substring slicing and concatenation.
- For each rotated version of the string, compare it with the target (goal) string.
- If a match is found at any point, return `true` immediately as the goal can be achieved.
- If none of the rotations match the goal string after checking all possibilities, return `false`.

![Image 1](https://static.takeuforward.org/content/1.png-kwAo05ZI)

![Image 2](https://static.takeuforward.org/content/2.png-DBxSGwRQ)

![Image 3](https://static.takeuforward.org/content/3.png-0RJGl626)

![Image 4](https://static.takeuforward.org/content/4.png-h04tCFz1)

![Image 5](https://static.takeuforward.org/content/5.png-sK4AAERE)

![Image 1](https://static.takeuforward.org/content/1.png-kwAo05ZI)![Image 2](https://static.takeuforward.org/content/2.png-DBxSGwRQ)![Image 3](https://static.takeuforward.org/content/3.png-0RJGl626)![Image 4](https://static.takeuforward.org/content/4.png-h04tCFz1)![Image 5](https://static.takeuforward.org/content/5.png-sK4AAERE)

Code

C++JavaPythonJavaScript

```java
class Solution {
    // Brute force approach to check if goal is a rotation of s
    public boolean rotateString(String s, String goal) {
        // Strings must be same length to be rotations of each other
        if (s.length() != goal.length()) {
            return false;
        }

        // Try all possible rotations of s
        for (int i = 0; i < s.length(); i++) {
            String rotated = s.substring(i) + s.substring(0, i);
            if (rotated.equals(goal)) {
                // Return true if a match is found
                return true;  
            }
        }

        return false;
    }
}

public class Main {
    public static void main(String[] args) {
        Solution sol = new Solution();

        String s1 = "rotation";
        String goal1 = "tionrota";
        System.out.println(sol.rotateString(s1, goal1)); 
    }
}
```

Complexity Analysis

**Time Complexity: O(N^2)** since generating N rotations and each comparison takes O(N) time.  
  
**Space Complexity: O(N)** for the space needed to store each rotated string.

Optimal Approach

Algorithm

- Double the original string by joining it with itself, creating a new string like s + s.
- Look for the target string goalinside this new doubled string.
- If goal exists within the doubled string, then it's a valid rotation, return true.
- If it's not found, that means the original string cannot be rotated to match goal, return false

![](https://static.takeuforward.org/content/-iTNGqiGt)

Code

C++JavaPythonJavaScript

```java
class Solution {
    // Method to check if one string is a rotation of another
    public boolean rotateString(String s, String goal) {
        // Check if lengths of both strings are unequal
        if (s.length() != goal.length()) {
            // Return false if lengths don't match
            return false;
        }
        // Concatenate the string with itself
        String doubledS = s + s;
        // Check if the goal is a substring of the concatenated string
        return doubledS.contains(goal);
    }
}

// Main class to run the test cases
public class Main {
    public static void main(String[] args) {
        // Create instance of Solution
        Solution sol = new Solution();

        System.out.println(sol.rotateString("rotation", "tionrota"));
    }
}
```

Complexity Analysis

**Time Complexity: O(N)**, because checking for a substring in s + s is linear in time.  
  
**Space Complexity: O(N)** for the space needed to store the concatenated string s + s.