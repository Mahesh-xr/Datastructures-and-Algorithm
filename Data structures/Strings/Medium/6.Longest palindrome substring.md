

Longest Palindromic Substring



**Problem Statement:** Given a string **s**, return the **longest palindromic substring** in s.

**Examples**

**Example 1:****Input:** s = "babad"
**Output:** "bab"
**Explanation:** It is the longest palindromic substring. "aba" is also a valid answer.

**Example 2:****Input:** s = "cbbd"
**Output:** "bb"
**Explanation:** It is the longest palindromic substring.

Approach

Algorithm

- The goal is to find the longest palindromic substring by treating each character (and each pair) as a potential center.
- Every palindrome is symmetric, so we expand outward from a center to check for symmetry.
- There are two types of centers to consider: one at a character (odd-length) and one between characters (even-length).
- For each center, expand left and right while the characters on both sides match.
- Keep track of the maximum length palindrome found by updating its start and end indices.
- The final result is the substring between the recorded boundaries of the longest expansion.

Code

C++JavaPythonJavaScript

```java
// Definition and Solution class
class Solution {

    // Helper function to expand around a center
    private int[] expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return new int[]{left + 1, right - 1};
    }

    // Function to return longest palindromic substring
    public String longestPalindrome(String s) {
        int n = s.length();
        if (n == 0) return "";

        int start = 0, end = 0;

        // Iterate through each index as potential center
        for (int i = 0; i < n; i++) {
            // Odd-length palindrome
            int[] odd = expandAroundCenter(s, i, i);
            // Even-length palindrome
            int[] even = expandAroundCenter(s, i, i + 1);

            // Update longest palindrome
            if (odd[1] - odd[0] > end - start) {
                start = odd[0];
                end = odd[1];
            }
            if (even[1] - even[0] > end - start) {
                start = even[0];
                end = even[1];
            }
        }

        return s.substring(start, end + 1);
    }
}

// Driver class
public class Main {
    public static void main(String[] args) {
        Solution sol = new Solution();
        String s = "babad";
        System.out.println(sol.longestPalindrome(s)); // Output: "bab" or "aba"
    }
}

```
Complexity Analysis

**Time Complexity: O(N²)** For each character, expanding could take up to O(N)  
  
**Space Complexity: O(1)** No extra space used.
