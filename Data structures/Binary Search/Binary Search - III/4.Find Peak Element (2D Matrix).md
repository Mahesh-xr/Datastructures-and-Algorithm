
Find Peak Element (2D Matrix)

**Problem Statement:** Given a 0-indexed n x m matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the array [i, j]. A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbours to the left, right, top, and bottom.  
Assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell.  
  
**Note:** As there can be many peak values, 1 is given as output if the returned index is a peak number, otherwise 0.

**Examples**

**Example 1:****Input:** mat = [[5, 10, 8], [4, 25, 7], [3, 9, 6]]
**Output:** [1, 1]
**Explanation:** The value at index [1, 1] is 25, which is a peak because all its neighbors (10, 7, 4, 9) are smaller.

**Example 2:****Input:** mat = [[1, 2, 3], [6, 5, 4], [7, 8, 9]]
**Output:** [2, 2]
**Explanation:** The value at index [2, 2] is 9, which is a peak as it is greater than its neighbors (8, 4).
            

Approach

Algorithm

To solve this problem we use the binary search approach.  
The key idea comes from how we find a peak in a 1-D array:

- For any middle position (mid), we check if it’s larger than both its neighbors, if it is, we’ve found a peak.
- If mid is smaller than the element on its left, that means a peak must be somewhere to the left, so we can discard the right half.
- If mid is smaller than the element on its right, then a peak must lie to the right, allowing us to discard the left half.
- This method reduces the number of elements we need to consider in every step, improving efficiency.

For a 2-D array,

- The search will cover the column range from 0 to col-1, where col is the total number of columns.
- We choose a middle column and identify the row with the largest element in that column.
- We apply similar logic as in 1-D: if this element is bigger than both its side neighbors, we’ve found the peak.
- If the left neighbor is bigger, we only search the left part; if the right neighbor is bigger, we search the right part.

  

![Image 1](https://static.takeuforward.org/content/peak1.drawio.png-pJBuYpSP)

![Image 2](https://static.takeuforward.org/content/peak2.drawio.png-keX4FMMq)

![Image 3](https://static.takeuforward.org/content/peak3.drawio.png-yeBgagCQ)

![Image 1](https://static.takeuforward.org/content/peak1.drawio.png-pJBuYpSP)![Image 2](https://static.takeuforward.org/content/peak2.drawio.png-keX4FMMq)![Image 3](https://static.takeuforward.org/content/peak3.drawio.png-yeBgagCQ)

Code

C++JavaPythonJavaScript

```java
import java.util.*;
  
  class Solution {
  
      // Helper function to find the index of the row 
      // with the maximum element in a given column
      public int maxElement(int[][] arr, int col) {
          int n = arr.length;
          int max = Integer.MIN_VALUE;
          int index = -1;
  
          // Iterate through each row to find the maximum element 
          // in the specified column
          for (int i = 0; i < n; i++) {
              if (arr[i][col] > max) {
                  max = arr[i][col];
                  index = i;
              }
          }
          return index;
      }
  
      // Function to find a peak element in the 2D matrix 
      // using binary search
      public int[] findPeakGrid(int[][] arr) {
          int n = arr.length;
          int m = arr[0].length;
  
          int low = 0;
          int high = m - 1;
  
          // Perform binary search on columns
          while (low <= high) {
              int mid = (low + high) / 2;
  
              // Find the index of the row with the maximum element 
              // in the middle column
              int row = maxElement(arr, mid);
  
              // Determine left and right neighbors of middle element
              int left = mid - 1 >= 0 ? arr[row][mid - 1] : Integer.MIN_VALUE;
              int right = mid + 1 < m ? arr[row][mid + 1] : Integer.MIN_VALUE;
  
              // Check if the middle element is a peak
              if (arr[row][mid] > left && arr[row][mid] > right) {
                  return new int[]{row, mid};
              } else if (left > arr[row][mid]) {
                  high = mid - 1;
              } else {
                  low = mid + 1;
              }
          }
  
          // Return [-1, -1] if no peak element is found
          return new int[]{-1, -1};
      }
  }
  
  public class Main {
      public static void main(String[] args) {
          int[][] mat = {
              {4, 2, 5, 1, 4, 5},
              {2, 9, 3, 2, 3, 2},
              {1, 7, 6, 0, 1, 3},
              {3, 6, 2, 3, 7, 2}
          };
  
          Solution sol = new Solution();
          int[] peak = sol.findPeakGrid(mat);
  
          System.out.println("The row of the peak element is " + peak[0] +
                             " and the column of the peak element is " + peak[1]);
      }
  }
```

Complexity Analysis

**Time Complexity: O(N * logM)**, where N is the number of rows in the matrix, M is the number of columns in each row. The complexity arises because binary search is performed on the columns, and for each mid column, a linear search through the rows is executed to find the maximum element.  
  
**Space Complexity: O(1)** as no additional space is used.

Video Solution