

**Problem Statement:** You have been given a 2-D array 'mat' of size 'N x M' where 'N' and 'M' denote the number of rows and columns, respectively. The elements of each row and each column are sorted in non-decreasing order. But, the first element of a row is not necessarily greater than the last element of the previous row (if it exists). You are given an integer ‘target’, and your task is to find if it exists in the given 'mat' or not.

**Examples**

Example 1:
Matrix=
1   4   7   11
2   5   8   12
3   6   9   16
10 13  14  17
Target: 9
Output: Found at (2,2) (0-indexed)


Example 2:
Matrix=
5   10  15
6   12  18
8   16  20
Target: 7
Output: Not Found

            

Brute Force

Algorithm

- We will use a loop to select a particular row at a time.
- Next, for every row, we will use another loop to traverse each column.
- Inside the loops, we will check if the element i.e. matrix[i][j] is equal to the ‘target’. If we found any matching element, we will return true.
- Finally, after completing the traversal, if we found no matching element, we will return false.

Code

C++JavaPythonJavaScript

```java
import java.util.*;

// Class to handle all operations related to matrix
class MatrixSearch {
    private int[][] matrix; // 2D array to store the matrix

    // Constructor to initialize matrix
    public MatrixSearch(int[][] matrix) {
        this.matrix = matrix;
    }

    // Function to search a target element in the matrix
    public boolean searchElement(int target) {
        int n = matrix.length;       // Number of rows
        int m = matrix[0].length;    // Number of columns

        // Loop through all rows
        for (int i = 0; i < n; i++) {
            // Loop through all columns in the current row
            for (int j = 0; j < m; j++) {
                // If we find the target, return true immediately
                if (matrix[i][j] == target) {
                    return true;
                }
            }
        }
        // Target not found after checking all elements
        return false;
    }

    public static void main(String[] args) {
        // Create a sample 2D matrix (sorted row-wise and column-wise)
        int[][] matrix = {
            {1, 4, 7, 11, 15},
            {2, 5, 8, 12, 19},
            {3, 6, 9, 16, 22},
            {10, 13, 14, 17, 24},
            {18, 21, 23, 26, 30}
        };

        // Instantiate MatrixSearch object
        MatrixSearch ms = new MatrixSearch(matrix);

        // Search for element 8
        boolean found = ms.searchElement(8);

        // Print the result
        System.out.println(found); // true
    }
}
```
Complexity Analysis

Time Complexity: O(N X M), where N = given row number, M = given column number in order to traverse the matrix, we are using nested loops running for n and m times respectively.

Space Complexity: O(1) as we are not using any extra space.

Better Approach

Algorithm

- We will use a loop to select a particular row at a time.
- Next, for every row, i, we will check if it contains the target using binary search.
- After applying binary search on row, if we found any element equal to the target, we will return true. Otherwise, we will move on to the next row.
- Finally, after completing all the row traversals, if we found no matching element, we will return false.

Code

C++JavaPythonJavaScript

```java
import java.util.*;

// Class to handle binary search in matrix
class MatrixSearch {
    private int[][] matrix; // Store the 2D matrix

    // Constructor
    public MatrixSearch(int[][] matrix) {
        this.matrix = matrix;
    }

    // Binary search helper function for 1D array
    private boolean binarySearch(int[] nums, int target) {
        int low = 0, high = nums.length - 1;

        // Binary search loop
        while (low <= high) {
            int mid = (low + high) / 2;

            if (nums[mid] == target) {
                return true; // Found target
            } else if (target > nums[mid]) {
                low = mid + 1; // Move to right half
            } else {
                high = mid - 1; // Move to left half
            }
        }
        return false; // Target not found
    }

    // Search target in matrix using binary search on each row
    public boolean searchElement(int target) {
        for (int i = 0; i < matrix.length; i++) {
            if (binarySearch(matrix[i], target)) {
                return true; // Found in current row
            }
        }
        return false; // Not found in any row
    }

    public static void main(String[] args) {
        int[][] matrix = {
            {1, 4, 7, 11, 15},
            {2, 5, 8, 12, 19},
            {3, 6, 9, 16, 22},
            {10, 13, 14, 17, 24},
            {18, 21, 23, 26, 30}
        };

        MatrixSearch ms = new MatrixSearch(matrix);
        boolean found = ms.searchElement(8);
        System.out.println(found); // true
    }
}
```
Complexity Analysis

Time Complexity: O(N*logM), where N = given row number, M = given column number. We are traversing all rows and it takes O(N) time complexity. And for all rows, we are applying binary search. So, the total time complexity is O(N*logM).

Space Complexity: O(1) as we are not using any extra space.

Optimal Approach

Algorithm

- As we are starting from the cell (0, m-1), the two variables i.e. ‘row’ and ‘col’ will point to 0 and m-1 respectively.
- We will do the following steps until row < n and col >= 0(i.e. while(row < n && col >= 0)):

- If matrix[row][col] == target: We have found the target and so we will return true.
- If matrix[row][col] > target: We need the smaller elements to reach the target. But the column is in increasing order and so it contains only greater elements. So, we will eliminate the column by decreasing the current column value by 1(i.e. col--) and thus we will move row-wise.
- If matrix[row][col] < target: In this case, We need the bigger elements to reach the target. But the row is in decreasing order and so it contains only smaller elements. So, we will eliminate the row by increasing the current row value by 1(i.e. row++) and thus we will move column-wise.

- If we are outside the loop without getting any matching element, we will return false.

![Image 1](https://static.takeuforward.org/content/1.png-wRezvqaX)

![Image 2](https://static.takeuforward.org/content/2.png-uDKdF723)

![Image 1](https://static.takeuforward.org/content/1.png-wRezvqaX)![Image 2](https://static.takeuforward.org/content/2.png-uDKdF723)

Code

C++JavaPythonJavaScript

```java
import java.util.*;

// Class to perform staircase search in a 2D sorted matrix
class MatrixSearch {
    private int[][] matrix; // Store matrix

    // Constructor to initialize the matrix
    public MatrixSearch(int[][] matrix) {
        this.matrix = matrix;
    }

    // Function to search target using staircase search
    public boolean searchElement(int target) {
        int n = matrix.length;        // Number of rows
        int m = matrix[0].length;     // Number of columns

        int row = 0;           // Start at first row
        int col = m - 1;       // Start at last column (top-right)

        // Traverse while within matrix bounds
        while (row < n && col >= 0) {
            if (matrix[row][col] == target) {
                return true; // Found target
            } else if (matrix[row][col] < target) {
                row++; // Move down
            } else {
                col--; // Move left
            }
        }

        return false; // Target not found
    }

    public static void main(String[] args) {
        int[][] matrix = {
            {1, 4, 7, 11, 15},
            {2, 5, 8, 12, 19},
            {3, 6, 9, 16, 22},
            {10, 13, 14, 17, 24},
            {18, 21, 23, 26, 30}
        };

        MatrixSearch ms = new MatrixSearch(matrix);
        boolean found = ms.searchElement(8);
        System.out.println(found); // true
    }
}
```
Complexity Analysis

Time Complexity: O(N+M), where N = given row number, M = given column number. We are starting traversal from (0, M-1), and at most, we can end up being in the cell (M-1, 0). So, the total distance can be at most (N+M). So, the time complexity is O(N+M).

Space Complexity: O(1) as we are not using any extra space.