
Median of Row Wise Sorted Matrix


**Problem Statement:**  
Given a row-wise sorted matrix of size M*N, where M is no. of rows and N is no. of columns, find the median in the given matrix.  
Note: M*N is odd.

**Examples**

Input: M = 3, N = 3, matrix[][] =
1 4 9 
2 5 6
3 8 7
Output: 5Explanation: 
If we find the linear sorted array, the array becomes 1 2 3 4 5 6 7 8 9. Therefore, median = 5

![](https://static.takeuforward.org/content/-CO6-aFzs)

Input: M = 3, N = 3, matrix[][] =
1 3 8 
2 3 4
1 2 5
Output: 3Explanation: 
If we find the linear sorted array, the array becomes 1 1 2 2 3 3 4 5 7 8. Therefore, median = 3.

![](https://static.takeuforward.org/content/-zMwSrQAE)

            

**_Disclaimer_**: _Here is the [practice link](https://takeuforward.org/plus/dsa/problems/matrix-median) to help you assess your knowledge better. It's highly recommend trying to solve it before looking at the solution._

Brute-Force Approach

Algorithm

The extremely naive approach is to use a linear array or list to store the elements of the given matrix and sort the list. We can return the middle element of sorted list to find the median.

![](https://static.takeuforward.org/content/-CO6-aFzs)

  

Code

C++JavaPythonJavaScript

```java
import java.util.*;

class Solution {
    // Function to find the median of a row-wise sorted matrix
    public int findMedian(int[][] matrix) {

        // Create a list to store all elements
        List<Integer> elements = new ArrayList<>();

        // Traverse each row of the matrix
        for (int[] row : matrix) {

            // Traverse each element in the current row
            for (int val : row) {

                // Add element to list
                elements.add(val);
            }
        }

        // Sort the list of elements
        Collections.sort(elements);

        // Return the middle element (median)
        int n = elements.size();
        return elements.get(n / 2);
    }
}

public class Main {
    public static void main(String[] args) {
        Solution obj = new Solution();

        // Define the matrix
        int[][] matrix = {
            {1, 3, 5},
            {2, 6, 9},
            {3, 6, 9}
        };

        // Print the median
        System.out.println(obj.findMedian(matrix));
    }
}
```
Complexity Analysis**Time Complexity: O(M*N*(log(M*N)))**, sorting the linear array takes time complexity of O(M*N(logM*N)).  
**Space Complexity: O(M*N)**, to create a linear array.  

Optimal Approach

Algorithm

In a row-wise sorted matrix, each row is individually sorted, but the entire matrix isn’t globally sorted. Hence, we can’t just pick the middle element directly to get the median. If we flatten and sort the entire matrix, it would take O(N×M log(N×M)) time, which is inefficient. Instead, we can take advantage of the sorted rows and apply a more optimized method using binary search on the value space (i.e., the range of possible numbers in the matrix).  
  
We start by finding the minimum and maximum elements in the matrix. The smallest element will be in the first column, and the largest element will be in the last column. We then binary search between this range to find the median value.  
  
In each iteration of the binary search, we choose a middle value and count how many elements in the matrix are less than or equal to it. Since each row is sorted, we can do this efficiently using binary search ([upper bound](https://takeuforward.org/arrays/implement-upper-bound/)) on each row. If the count is less than or equal to half of the total number of elements, we move our search range to the right, otherwise, we move it to the left.

![Image 1](https://static.takeuforward.org/content/op1.png-4hG4Oy93)

![Image 2](https://static.takeuforward.org/content/op2.png-QHabp8GK)

![Image 1](https://static.takeuforward.org/content/op1.png-4hG4Oy93)![Image 2](https://static.takeuforward.org/content/op2.png-QHabp8GK)

Code

C++JavaPythonJavaScript

```java
import java.util.*;

class Solution {
    // Function to count elements less than or equal to mid in a row
    int countLessEqual(int[] row, int mid) {
        // Binary search in row
        int low = 0, high = row.length;
        while (low < high) {
            int m = (low + high) / 2;
            if (row[m] <= mid) low = m + 1;
            else high = m;
        }
        return low;
    }

    // Function to find the median
    int findMedian(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;

        // Initialize low and high values
        int low = matrix[0][0];
        int high = matrix[0][cols - 1];
        for (int i = 1; i < rows; i++) {
            low = Math.min(low, matrix[i][0]);
            high = Math.max(high, matrix[i][cols - 1]);
        }

        // Binary search in value range
        while (low < high) {
            int mid = (low + high) / 2;
            int count = 0;

            // Count number of elements ≤ mid
            for (int i = 0; i < rows; i++) {
                count += countLessEqual(matrix[i], mid);
            }

            if (count < (rows * cols + 1) / 2)
                low = mid + 1;
            else
                high = mid;
        }

        // Return the median
        return low;
    }

    public static void main(String[] args) {
        Solution obj = new Solution();
        int[][] matrix = {
            {1, 3, 5},
            {2, 6, 9},
            {3, 6, 9}
        };
        System.out.println("Median: " + obj.findMedian(matrix));
    }
}
```
Complexity Analysis**Time Complexity: O(rows × log(max - min) × log(cols))**, Binary search runs on the value space from min to max of the matrix and for each mid in binary search, we count how many numbers are less than or equal to mid  
**Space Complexity: O(1)**, constant extra space is used.