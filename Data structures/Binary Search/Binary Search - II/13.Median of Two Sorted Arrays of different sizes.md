
Median of Two Sorted Arrays of different sizes



**Problem Statement:**  
Given two sorted arrays arr1 and arr2 of size m and n respectively, return the median of the two sorted arrays. The median is defined as the middle value of a sorted list of numbers. In case the length of the list is even, the median is the average of the two middle elements.

**Examples**

Input: n1 = 3, arr1[] = {2,4,6}, n2 = 3, arr2[] = {1,3,5}Output: 3.5Explanation: 
The array after merging 'a' and 'b' will be {1, 2, 3, 4, 5, 6}. As the length of the merged list is even, the median is the average of the two middle elements. Here two medians are 3 and 4. So the median will be the average of 3 and 4, which is 3.5.

Input: n1 = 3, arr1[] = {2,4,6}, n2 = 2, arr2[] = {1,3}Output: 3Explanation: 
The array after merging 'a' and 'b' will be { 1, 2, 3, 4, 6 }. The median is 3.
            

**_Disclaimer_**: _Here is the [practice link](https://takeuforward.org/plus/dsa/problems/median-of-2-sorted-arrays) to help you assess your knowledge better. It's highly recommend trying to solve it before looking at the solution._

Brute-Force Approach

Algorithm

The extremely naive approach is to merge the two sorted arrays and then find the median in that merged array.  
  
To merge the two arrays we will be applying the merge step of the [merge sort algorithm](https://takeuforward.org/data-structure/merge-sort-algorithm/). In that step, we essentially perform the same actions as required by this solution. By using two pointers on two given arrays, we fill up the elements into a third array.  
  
After merging, if the length of the new array is even, we return the average of the two middle elements or else we simply return the middle element as the median.  
  

![Image 1](https://static.takeuforward.org/content/br1.png-c5LsFXhd)

![Image 2](https://static.takeuforward.org/content/br2.png-vdKlcd9k)

![Image 3](https://static.takeuforward.org/content/br3.png-w_59htzi)

![Image 4](https://static.takeuforward.org/content/br4.png-N7VZD07P)

![Image 1](https://static.takeuforward.org/content/br1.png-c5LsFXhd)![Image 2](https://static.takeuforward.org/content/br2.png-vdKlcd9k)![Image 3](https://static.takeuforward.org/content/br3.png-w_59htzi)![Image 4](https://static.takeuforward.org/content/br4.png-N7VZD07P)

  

Code

C++JavaPythonJavaScript

```java
import java.util.*;

class Solution {

    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        
        // Create a list to store merged sorted elements
        List<Integer> merged = new ArrayList<>();
        
        // Initialize two pointers to traverse both arrays
        int i = 0, j = 0;

        // Merge both arrays into the merged list in sorted order
        while (i < nums1.length && j < nums2.length) {
            // If element in nums1 is smaller, add to merged
            if (nums1[i] < nums2[j])
                merged.add(nums1[i++]);
            else
                merged.add(nums2[j++]);
        }

        // Add any remaining elements from nums1
        while (i < nums1.length)
            merged.add(nums1[i++]);

        // Add any remaining elements from nums2
        while (j < nums2.length)
            merged.add(nums2[j++]);

        // Find the size of the merged array
        int n = merged.size();

        // If size is odd, return the middle element
        if (n % 2 == 1)
            return merged.get(n / 2);

        // If size is even, return the average of the two middle elements
        return (merged.get(n / 2 - 1) + merged.get(n / 2)) / 2.0;
    }
}

public class Main {

    public static void main(String[] args) {
        
        // Create object of Solution class
        Solution sol = new Solution();

        // Define two input sorted arrays
        int[] nums1 = {1, 3};
        int[] nums2 = {2};

        // Call function to get median
        double median = sol.findMedianSortedArrays(nums1, nums2);

        // Print the median result
        System.out.println(median);
    }
}
```
Complexity Analysis**Time Complexity: O(N1+N2))**, every element of both array is visited once.  
**Space Complexity: O(N1+N2)**, to store the merged array.  

Better Approach

Algorithm

To optimize the space used in the previous approach, we can eliminate the third array used to store the final merged result. After closer examination, we realize that we only need the two middle elements, rather than the entire merged array, to solve the problem effectively.  
  
We will stick to the same basic approach, but instead of storing elements in a separate array, we will use a counter to represent the imaginary third array's index. As we traverse through the arrays, when counter reaches the middle index, we will store that particular element. This way, we can achieve the same goal without using any extra space.

Code

C++JavaPythonJavaScript

```java
import java.util.*;

class Solution {

    // Function to find the median
    public static double median(int[] a, int[] b) {

        // Get sizes of both arrays
        int n1 = a.length, n2 = b.length;

        // Total size
        int n = n1 + n2;

        // Median indices
        int ind2 = n / 2;
        int ind1 = ind2 - 1;

        // Initialize pointers and values
        int cnt = 0, i = 0, j = 0;
        int ind1el = -1, ind2el = -1;

        // Merge step to find median
        while (i < n1 && j < n2) {
            if (a[i] < b[j]) {
                if (cnt == ind1) ind1el = a[i];
                if (cnt == ind2) ind2el = a[i];
                i++;
            } else {
                if (cnt == ind1) ind1el = b[j];
                if (cnt == ind2) ind2el = b[j];
                j++;
            }
            cnt++;
        }

        // Remaining elements in a
        while (i < n1) {
            if (cnt == ind1) ind1el = a[i];
            if (cnt == ind2) ind2el = a[i];
            cnt++;
            i++;
        }

        // Remaining elements in b
        while (j < n2) {
            if (cnt == ind1) ind1el = b[j];
            if (cnt == ind2) ind2el = b[j];
            cnt++;
            j++;
        }

        // Return median
        if (n % 2 == 1) return (double) ind2el;
        return (ind1el + ind2el) / 2.0;
    }
}

public class Main {
    public static void main(String[] args) {

        // Input arrays
        int[] a = {1, 4, 7, 10, 12};
        int[] b = {2, 3, 6, 15};

        // Output the result
        System.out.printf("The median is %.1f\n", Solution.median(a, b));
    }
}
```
Complexity Analysis**Time Complexity: O(N1+N2)**, every element of both the arrays is visited once.  
**Space Complexity: O(1)**, constant extra space is used.  

Optimal Approach

Algorithm

To find the median of two sorted arrays efficiently, we use binary search on the smaller array to minimize time complexity. The key idea is to partition both arrays such that the left half contains the smaller elements and the right half contains the larger elements. This way, the median lies at the boundary between the two halves.  
  
We choose a cut (partition) in the first array, and accordingly calculate the cut in the second array such that the total number of elements on the left side equals the number of elements on the right (or differs by one if the total number is odd). For the correct partition, the maximum of the left parts should be less than or equal to the minimum of the right parts.  
  
To check this, we compare the maximum of the left side from both arrays with the minimum of the right side. If the condition is not met, we move the binary search window either left or right depending on which condition fails. This process continues until we find the right partition.  
  
Once the correct partition is found, the median is calculated based on the total number of elements. If the total is even, we take the average of the two middle values (i.e., max of left part and min of right part). If the total is odd, the median is the max of the left part since it would be the middle element.  

![Image 1](https://static.takeuforward.org/content/op1.png-D3BbE-3d)

![Image 2](https://static.takeuforward.org/content/op2.png-f0MlwORl)

![Image 3](https://static.takeuforward.org/content/op3.png-_v294zwR)

![Image 1](https://static.takeuforward.org/content/op1.png-D3BbE-3d)![Image 2](https://static.takeuforward.org/content/op2.png-f0MlwORl)![Image 3](https://static.takeuforward.org/content/op3.png-_v294zwR)

  

Code

C++JavaPythonJavaScript

```java
import java.util.*;

class Solution {
    public double findMedianSortedArrays(int[] a, int[] b) {
        // Make sure array a is the smaller one to minimize binary search range
        if (a.length > b.length) return findMedianSortedArrays(b, a);

        int n1 = a.length, n2 = b.length;
        int low = 0, high = n1;

        // Binary search on the smaller array
        while (low <= high) {
            // Calculate cut points for both arrays
            int cut1 = (low + high) / 2;
            int cut2 = (n1 + n2 + 1) / 2 - cut1;

            // Get values to the left and right of the partition
            // Use Integer.MIN_VALUE and MAX_VALUE to handle edge cases
            int l1 = (cut1 == 0) ? Integer.MIN_VALUE : a[cut1 - 1];
            int l2 = (cut2 == 0) ? Integer.MIN_VALUE : b[cut2 - 1];
            int r1 = (cut1 == n1) ? Integer.MAX_VALUE : a[cut1];
            int r2 = (cut2 == n2) ? Integer.MAX_VALUE : b[cut2];

            // If partition is valid
            if (l1 <= r2 && l2 <= r1) {
                // Even total elements => average of two middle elements
                if ((n1 + n2) % 2 == 0)
                    return (Math.max(l1, l2) + Math.min(r1, r2)) / 2.0;
                else
                    // Odd total elements => max of left parts
                    return Math.max(l1, l2);
            }
            // Move left in array a
            else if (l1 > r2)
                high = cut1 - 1;
            // Move right in array a
            else
                low = cut1 + 1;
        }

        return 0.0; 
    }
}

public class Main {
    public static void main(String[] args) {
        Solution sol = new Solution();
        int[] a = {1, 3};
        int[] b = {2};
        System.out.println("Median is: " + sol.findMedianSortedArrays(a, b));
    }
}
```
Complexity Analysis**Time Complexity: O(log(min(n1,n2)))**, we are applying binary search on the range [0, min(n1, n2)].  
**Space Complexity: O(1)** , only constant variables are used.