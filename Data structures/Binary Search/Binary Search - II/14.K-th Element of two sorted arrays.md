
K-th Element of two sorted arrays


**Problem Statement:**Â Given two sorted arrays a and b of size m and n respectively. Find the kth element of the final sorted array.

**Examples**

**Example 1:****Input:** a = [2, 3, 6, 7, 9], b = [1, 4, 8, 10], k = 5  
**Output:** 6  
**Explanation:** The final sorted array would be [1, 2, 3, 4, 6, 7, 8, 9, 10]. The 5th element of this array is 6.

**Example 2:****Input:** a = [100, 112, 256, 349, 770], b = [72, 86, 113, 119, 265, 445, 892], k = 7  
**Output:** 256  
**Explanation:** The final sorted array is [72, 86, 100, 112, 113, 119, 256, 265, 349, 445, 770, 892]. The 7th element of this array is 256.

Approach

Algorithm

- First, ensure that arr1 is the smaller array. If not, swap the arrays. Our goal is to treat arr1[] as the smaller array.
- Calculate the length of the left half as left = k.
- Initialize two pointers:
    - low will point to max(0, k - n2),
    - high will point to min(k, n1) (n1 is the size of the smaller array and n2 is the size of the larger array).
- Calculate 'mid1' and 'mid2':
    - mid1 = (low + high) // 2 (integer division),
    - mid2 = left - mid1.
- Inside the loop, calculate l1, l2, r1, and r2:
    - l1 = arr1[mid1 - 1],
    - l2 = arr2[mid2 - 1],
    - r1 = arr1[mid1],
    - r2 = arr2[mid2].
    - If mid1 or mid2 is out of bounds, set l1, l2 to INT_MIN and r1, r2 to INT_MAX.
- Eliminate halves based on the following conditions:
    - If l1 <= r2 and l2 <= r1, the answer is found. Return the maximum of l1 and l2.
    - If l1 > r2, eliminate the right half by setting high = mid1 - 1.
    - If l2 > r1, eliminate the left half by setting low = mid1 + 1.
- When the loop terminates, include a dummy return statement to avoid warnings or errors.

![Image 1](https://static.takeuforward.org/content/1.png-NAWRIB1f)

![Image 2](https://static.takeuforward.org/content/2.png-D8VYDrzn)

![Image 3](https://static.takeuforward.org/content/3.png-cGjpH_6-)

![Image 1](https://static.takeuforward.org/content/1.png-NAWRIB1f)![Image 2](https://static.takeuforward.org/content/2.png-D8VYDrzn)![Image 3](https://static.takeuforward.org/content/3.png-cGjpH_6-)

Code

C++JavaPythonJavaScript

```java
import java.util.*;

class Solution {
    public int kthElement(int[] a, int[] b, int k) {
        int m = a.length;
        int n = b.length;

        // Ensure 'a' is the smaller array for optimization
        if (m > n) {
            return kthElement(b, a, k);
        }

        int left = k; // Number of elements in the left partition
        int low = Math.max(0, k - n), high = Math.min(k, m);

        while (low <= high) {
            int mid1 = (low + high) >> 1;
            int mid2 = left - mid1;

            int l1 = (mid1 > 0) ? a[mid1 - 1] : Integer.MIN_VALUE;
            int l2 = (mid2 > 0) ? b[mid2 - 1] : Integer.MIN_VALUE;
            int r1 = (mid1 < m) ? a[mid1] : Integer.MAX_VALUE;
            int r2 = (mid2 < n) ? b[mid2] : Integer.MAX_VALUE;

            if (l1 <= r2 && l2 <= r1) {
                return Math.max(l1, l2);
            } else if (l1 > r2) {
                high = mid1 - 1; // Move left
            } else {
                low = mid1 + 1; // Move right
            }
        }

        return -1; // Should never reach here if inputs are valid
    }
}

public class Main {
    public static void main(String[] args) {
        int[] a = {2, 3, 6, 7, 9};
        int[] b = {1, 4, 8, 10};
        int k = 5;

        Solution solution = new Solution();
        System.out.println("The " + k + "-th element of two sorted arrays is: " +
                solution.kthElement(a, b, k));
    }
}
```
Complexity Analysis

**Time Complexity: O(log(min(M, N)))**, where M and N are the sizes of the two given arrays. As binary search is being applied on the range [max(0, k - N2), min(k, N1)], the range length <= min(M, N).  
  
**Space Complexity: O(1)**, as no additional space is used.