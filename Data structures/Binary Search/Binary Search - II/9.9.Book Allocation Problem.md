
Allocate Minimum Number of Pages


**Problem Statement:** Given an array ‘arr of integer numbers, ‘ar[i]’ represents the number of pages in the ‘i-th’ book. There are a ‘m’ number of students, and the task is to allocate all the books to the students.  
Allocate books in such a way that:

1. Each student gets at least one book.
2. Each book should be allocated to only one student.
3. Book allocation should be in a contiguous manner.

You have to allocate the book to ‘m’ students such that the maximum number of pages assigned to a student is minimum. If the allocation of books is not possible. return -1

**Examples**

**Example 1:**
Input Format: n = 4, m = 2, arr[] = {12, 34, 67, 90}
Result: 113
Explanation: The allocation of books will be 12, 34, 67 | 90. One student will get the first 3 books and the other will get the last one.

**Example 2:****Input Format:** n = 5, m = 4, arr[] = {25, 46, 28, 49, 24}
**Result:** 71
Explanation: The allocation of books will be 25, 46 | 28 | 49 | 24.

**Practice:**

[Solve Problem!

Brute Force Approach

Algorithm

1. **If m > n:** In this case, book allocation is not possible and so, we will return -1.
2. Next, we will find the maximum element and the summation of the given array.
3. We will use a loop(say **pages**) to check all possible pages from max(arr[]) to sum(arr[]).
4. Next, inside the loop, we will send each ‘pages’, to the function **countStudents()** function to get the number of students to whom we can allocate the books.
    1. The first number of pages, ‘pages’, for which the number of students will be equal to ‘m’, will be our answer. So, we will return that particular ‘pages’.
5. Finally, if we are out of the loop, we will return max(arr[]) as there cannot exist any answer smaller than that.

Code

C++JavaPythonJavaScript

```java
import java.util.*;

public class Solution {
    public static int countStudents(ArrayList<Integer> arr, int pages) {
        int n = arr.size(); // size of array
        int students = 1;
        long pagesStudent = 0;
        for (int i = 0; i < n; i++) {
            if (pagesStudent + arr.get(i) <= pages) {
                // add pages to current student
                pagesStudent += arr.get(i);
            } else {
                // add pages to next student
                students++;
                pagesStudent = arr.get(i);
            }
        }
        return students;
    }

    public static int findPages(ArrayList<Integer> arr, int n, int m) {
        // book allocation impossible
        if (m > n)
            return -1;

        int low = Collections.max(arr);
        int high = arr.stream().mapToInt(Integer::intValue).sum();

        for (int pages = low; pages <= high; pages++) {
            if (countStudents(arr, pages) == m) {
                return pages;
            }
        }
        return low;
    }

    public static void main(String[] args) {
        ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(25, 46, 28, 49, 24));
        int n = 5;
        int m = 4;
        int ans = findPages(arr, n, m);
        System.out.println("The answer is: " + ans);
    }
}
```

Complexity Analysis

**Time Complexity:** O(N * (sum(arr[])-max(arr[])+1)), where N = size of the array, sum(arr[]) = sum of all array elements, max(arr[])

**

**Space Complexity:**  O(1) as we are not using any extra space to solve this problem.

**

**

Optimal Approach

Algorithm

- This problem is solved using Binary Search to efficiently find the best way to distribute books among students.
- The main idea is to cut the search range in half each time by checking whether a certain number of pages per student is possible or not.
- The possible range of answers lies between the largest book (since no student can receive less than the largest book) and the total number of pages (which means giving all books to one student).

- First, if there are more students than books, it's impossible to assign at least one book to each student, so we return -1.
- Next, we search between the minimum and maximum possible values:
    - The minimum possible is the largest single book (because every student must get at least one complete book).
    - The maximum possible is the sum of all pages (if one student reads all books).
- We perform Binary Search:
    - We try a middle value of pages per student.
    - We check how many students would be required if no student gets more than that value.
    - If it takes more students than allowed, that value is too low, so we try a higher one.
    - If it fits within the allowed number of students, we store it and try a smaller one to find an even better option.
- Eventually, we land on the smallest value that works this is our answer.

- Note: After the binary search loop ends, the pointer will be on the smallest possible maximum number of pages per student. That's why it gives the correct result directly.

Code

C++JavaPythonJavaScript

```java
import java.util.*;

public class Solution {
    public static int countStudents(ArrayList<Integer> arr, int pages) {
        int n = arr.size(); // size of array
        int students = 1; //Students are initially 1
        long pagesStudent = 0;
        for (int i = 0; i < n; i++) {
            if (pagesStudent + arr.get(i) <= pages) {
                // add pages to current student
                pagesStudent += arr.get(i);
            } else {
                // add pages to next student
                students++;
                pagesStudent = arr.get(i);
            }
        }
        return students;
    }

    public static int findPages(ArrayList<Integer> arr, int n, int m) {
        // book allocation impossible
        if (m > n)
            return -1;

        int low = Collections.max(arr);
        int high = arr.stream().mapToInt(Integer::intValue).sum();
        while (low <= high) {
            int mid = (low + high) / 2;
            int students = countStudents(arr, mid);
            if (students > m) {
                low = mid + 1;  //Trim down the left part of the arry
            } else {
                high = mid - 1; //Trim down the right part of the array
            }
        }
        return low;
    }

    public static void main(String[] args) {
        ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(25, 46, 28, 49, 24));
        int n = 5;
        int m = 4;
        int ans = findPages(arr, n, m);
        System.out.println("The answer is: " + ans);
    }
}
```

Complexity Analysis

**Time Complexity:** O(N * log(sum(arr[])-max(arr[])+1)), where N = size of the array, sum(arr[]) = sum of all array elements, max(arr[]) = maximum of all array elements.  


**Space Complexity:**  O(1) as we are not using any extra space to solve this problem.

