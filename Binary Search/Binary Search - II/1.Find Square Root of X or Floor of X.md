
Finding Sqrt of a number using Binary Search

**Problem Statement:** You are given a positive integer n. Your task is to find and return its square root. If ‘n’ is not a perfect square, then return the floor value of sqrt(n).

**Examples**

Input: N = 36
Output: 6
Explanation: Square root of 36 is 6. 

Input: N = 28
Output: 5
Explanation: Square root of 28 is approximately 5.292. So, the floor value will be 5. 
            

**_Disclaimer_**: _Here is the [practice link](https://takeuforward.org/plus/dsa/problems/find-square-root-of-a-number) to help you assess your knowledge better. It's highly recommend trying to solve it before looking at the solution._

Brute-Force Approach

Algorithm

The idea is that the square root of a number n will always lie between 1 and n. So, we can linearly search in this range to find the largest integer x such that square of x is less than or equal to number n.

- Start by creating a variable called ans to hold the result and run a loop from 1 up to n.
- While the square of the current number is less than or equal to n, keep updating ans with that number.
- As soon as the square of the number becomes greater than n, stop the loop because no bigger number can be the answer.
- At the end, the value stored in ans will be the integer square root of n.

Code

CppJavaPythonJavascript

```java
class Solution {
    // Function to find floor of square root using linear search
    public int floorSqrt(int n) {
        // Variable to store answer
        int ans = 0;

        // Run loop from 1 to n
        for (int i = 1; i <= n; i++) {
            // Check if i*i <= n
            if ((long)(i) * i <= n) {
                // Update answer
                ans = i;
            } else {
                // Break when i*i > n
                break;
            }
        }
        // Return final answer
        return ans;
    }
}

public class Main {
    public static void main(String[] args) {
        // Example input
        int n = 27;

        // Create object of Solution
        Solution sol = new Solution();

        // Call function and print result
        System.out.println(sol.floorSqrt(n));
    }
}
```
Complexity Analysis**Time Complexity: O(N)**, we check for every number from 1 to N.  
**Space Complexity: O(1)**, since the algorithm does not use any additional space or data structures.

Optimal Approach

Algorithm

The naive method tries every number, which is slow when n is large. But our possible answer space (from 1 to n) is sorted, meaning if a certain number squared is less than or equal to n, then all smaller numbers will also work. This allows us to apply Binary Search on the answer space to efficiently find the largest number whose square is less than or equal to n.

- First, note that the answer lies between 1 and the given number n.
- Set the search range with the smallest value as 1 and the largest value as n.
- Use binary search within this range to test possible numbers.
- At each step, take the middle number and check if its square is less than or equal to n.
- If it is, record this number as a candidate and move right to check for a larger number.
- If the square is greater than n, move left to check smaller numbers.
- Continue this process until the range closes, and the largest recorded number will be the square root.

Code

CppJavaPythonJavascript

```java
class Solution {
    // This function returns the floor value of the square root of a number
    public int mySqrt(int x) {
        // Handle small numbers directly
        if (x < 2) return x;

        // Initialize binary search range
        int left = 1, right = x / 2, ans = 0;

        // Perform binary search
        while (left <= right) {
            // Find middle point
            long mid = left + (right - left) / 2;

            // Check if mid*mid is less than or equal to x
            if (mid * mid <= x) {
                // Store mid as potential answer
                ans = (int) mid;
                // Move to right half
                left = (int) mid + 1;
            } else {
                // Move to left half
                right = (int) mid - 1;
            }
        }

        // Return final answer
        return ans;
    }
}

public class Main {
    public static void main(String[] args) {
        Solution s = new Solution();
        System.out.println(s.mySqrt(8));
    }
}
```
Complexity Analysis**Time Complexity: O(log(N))**, we apply binary search on our search space to reduce it into half at every step.  
**Space Complexity: O(1)**, since the algorithm does not use any additional space or data structures.

