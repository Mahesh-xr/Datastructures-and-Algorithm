
Koko Eating Bananas

**Problem Statement:** A monkey Koko is given ‘n’ piles of bananas, whereas the 'ith' pile has ‘a[i]’ bananas. An integer ‘h’ is also given, which denotes the time (in hours) for all the bananas to be eaten.  
  
Each hour, the monkey chooses a non-empty pile of bananas and eats ‘k’ bananas. If the pile contains less than ‘k’ bananas, then the monkey consumes all the bananas and won’t eat any more bananas in that hour.  
  
Find the minimum number of bananas ‘k’ to eat per hour so that the monkey can eat all the bananas within ‘h’ hours.

**Examples**

Input: N = 4, a[] = {7, 15, 6, 3}, h = 8
Output: 5
Explanation:  If Koko eats 5 bananas/hr, he will take 2, 3, 2, and 1 hour to eat the piles accordingly. So, he will take 8 hours to complete all the piles.  

Input: N = 5, a[] = {25, 12, 8, 14, 19}, h = 5
Output: 25
Explanation: If Koko eats 25 bananas/hr, he will take 1, 1, 1, 1, and 1 hour to eat the piles accordingly. 
            

**_Disclaimer_**: _Here is the [practice link](https://takeuforward.org/plus/dsa/problems/koko-eating-bananas) to help you assess your knowledge better. It's highly recommend trying to solve it before looking at the solution._

Brute-Force Approach

Algorithm

The problem is about finding the minimum eating speed such that Koko can finish all bananas within h hours. The extremely naive approach is to check all possible answers from 1 to max(a[]). The minimum number for which the required time is less than or equal to h is our answer.

- Find the largest pile size (max of the array).
- Loop through all possible speeds from 1 to this maximum value.
- For each speed, calculate the total hours needed. For each pile, compute the time as ceil(pile / speed).
- Sum up the hours for all piles.
- If the total hours is less than or equal to the allowed hours, return this speed as the answer.

Code

CppJavaPythonJavascript

```java
import java.util.*;

class Solution {
    // Function to calculate total hours for given speed
    public int calculateTotalHours(int[] a, int hourly) {
        int totalHours = 0;
        for (int pile : a) {
            // Add hours using ceil
            totalHours += (int)Math.ceil((double)pile / hourly);
        }
        return totalHours;
    }

    // Function to find minimum eating speed
    public int minEatingSpeed(int[] a, int h) {
        // Find maximum pile size
        int maxVal = Arrays.stream(a).max().getAsInt();

        // Try every possible speed
        for (int i = 1; i <= maxVal; i++) {
            int hours = calculateTotalHours(a, i);

            // If hours fit within h
            if (hours <= h) {
                return i;
            }
        }
        return maxVal;
    }
}

public class Main {
    public static void main(String[] args) {
        // Input array
        int[] a = {3, 6, 7, 11};
        // Hours allowed
        int h = 8;

        Solution obj = new Solution();
        System.out.println(obj.minEatingSpeed(a, h));
    }
}
```
Complexity Analysis**Time Complexity: O(n * max(a[]))**, since for each possible speed we go through all the piles.  
**Space Complexity: O(1)**, since the algorithm does not use any additional space or data structures.

Optimal Approach

Algorithm

The naive method checks every speed, which is slow if the piles are large. But the possible answer space (from 1 to the maximum pile size) is sorted, meaning if a certain speed works, then all higher speeds will also work. This allows us to apply Binary Search on the answer space to efficiently find the minimum speed at which Koko can finish the bananas within the given hours.

- First, identify the largest pile size since the eating speed cannot be more than that.
- Set the search range with the lowest speed as 1 and the highest speed as the maximum pile size.
- Use binary search within this range to check possible speeds.
- At each step, take the middle value as the current speed and calculate how many hours it would take to finish all piles at this speed.
- If the total hours are less than or equal to the allowed hours, this speed is a candidate, so try to see if a smaller speed also works by moving left.
- If the total hours exceed the allowed hours, then the speed is too slow, so move right to try higher speeds.
- Continue this process until the range closes, and the smallest valid speed found will be the answer.

Code

CppJavaPythonJavascript

```java
import java.util.*;

class Solution {
    // Function to calculate total hours at given speed
    private int calculateTotalHours(int[] piles, int speed) {
        int totalH = 0;
        for (int bananas : piles) {
            totalH += (int)Math.ceil((double)bananas / speed);
        }
        return totalH;
    }

    // Function to find minimum eating speed
    public int minEatingSpeed(int[] piles, int h) {
        // Find maximum element
        int maxPile = Arrays.stream(piles).max().getAsInt();

        // Initialize low and high pointers
        int low = 1, high = maxPile;
        int ans = maxPile;

        // Binary search on answer space
        while (low <= high) {
            int mid = (low + high) / 2;
            int totalH = calculateTotalHours(piles, mid);

            // If possible, try smaller speed
            if (totalH <= h) {
                ans = mid;
                high = mid - 1;
            }
            // Otherwise, try larger speed
            else {
                low = mid + 1;
            }
        }
        return ans;
    }
}

public class Main {
    public static void main(String[] args) {
        int[] piles = {3, 6, 7, 11};
        int h = 8;

        Solution obj = new Solution();
        System.out.println(obj.minEatingSpeed(piles, h));
    }
}
```
Complexity Analysis**Time Complexity: O(N*log(max(a[])))**, we apply binary search on our search space to reduce it into half at every step.  
**Space Complexity: O(1)**, since the algorithm does not use any additional space or data structures.

